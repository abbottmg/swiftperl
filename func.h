// !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
// This file is built by update-headers from data in embed.fnc.
// Any changes made here will be lost!
//
// Edit update-headers and run it to effect changes.

#ifdef av_clear
/// Frees the all the elements of an array, leaving it empty.
/// The XS equivalent of @c @@array @c = @c ().  See also av_undef.
///
/// Note that it is possible that the actions of a destructor called directly
/// or indirectly by freeing an element of the array could cause the reference
/// count of the array itself to be reduced (e.g. by deleting an entry in the
/// symbol table). So it is a possibility that the AV could have been freed
/// (or even reallocated) on return from the call unless you hold a reference
/// to it.
SWIFT_NAME(PerlInterpreter.av_clear(self:_:))
PERL_STATIC_INLINE void CPerl_av_clear(pTHX_ AV *_Nonnull av) {
	av_clear(av);
}
#endif

#ifdef av_delete
/// Deletes the element indexed by @c key from the array, makes the element
/// mortal, and returns it.  If @c flags equals @c G_DISCARD, the element is
/// freed and NULL is returned. NULL is also returned if @c key is out of
/// range.
///
/// Perl equivalent: @c splice(@@myarray, @c $key, @c 1, @c undef) (with the
/// @c splice in void context if @c G_DISCARD is present).
SWIFT_NAME(PerlInterpreter.av_delete(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nullable CPerl_av_delete(pTHX_ AV *_Nonnull av, SSize_t key, I32 flags) {
	return av_delete(av, key, flags);
}
#endif

#ifdef av_exists
/// Returns true if the element indexed by @c key has been initialized.
///
/// This relies on the fact that uninitialized array elements are set to
/// @c NULL.
///
/// Perl equivalent: @c exists($myarray[$key]).
SWIFT_NAME(PerlInterpreter.av_exists(self:_:_:))
PERL_STATIC_INLINE bool CPerl_av_exists(pTHX_ AV *_Nonnull av, SSize_t key) {
	return av_exists(av, key);
}
#endif

#ifdef av_extend
/// Pre-extend an array.  The @c key is the index to which the array should be
/// extended.
SWIFT_NAME(PerlInterpreter.av_extend(self:_:_:))
PERL_STATIC_INLINE void CPerl_av_extend(pTHX_ AV *_Nonnull av, SSize_t key) {
	av_extend(av, key);
}
#endif

#ifdef av_fetch
/// Returns the SV at the specified index in the array.  The @c key is the
/// index.  If lval is true, you are guaranteed to get a real SV back (in case
/// it wasn't real before), which you can then modify.  Check that the return
/// value is non-null before dereferencing it to a @c SV*.
///
/// See "Understanding the Magic of Tied Hashes and Arrays" in perlguts for
/// more information on how to use this function on tied arrays.
///
/// The rough perl equivalent is @c $myarray[$key].
SWIFT_NAME(PerlInterpreter.av_fetch(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nullable *_Nullable CPerl_av_fetch(pTHX_ AV *_Nonnull av, SSize_t key, bool lval) {
	return av_fetch(av, key, lval);
}
#endif

#ifdef av_fill
/// Set the highest index in the array to the given number, equivalent to
/// Perl's @c $#array @c = @c $fill;.
///
/// The number of elements in the array will be @c fill @c + @c 1 after
/// @c av_fill() returns.  If the array was previously shorter, then the
/// additional elements appended are set to NULL.  If the array
/// was longer, then the excess elements are freed.  @c av_fill(av, @c -1) is
/// the same as @c av_clear(av).
SWIFT_NAME(PerlInterpreter.av_fill(self:_:_:))
PERL_STATIC_INLINE void CPerl_av_fill(pTHX_ AV *_Nonnull av, SSize_t fill) {
	av_fill(av, fill);
}
#endif

#ifdef av_len
/// Same as av_top_index.  Note that, unlike what the name implies, it returns
/// the highest index in the array, so to get the size of the array you need to use
/// @c av_len(av) @c + @c 1.  This is unlike sv_len, which returns what you would
/// expect.
SWIFT_NAME(PerlInterpreter.av_len(self:_:))
PERL_STATIC_INLINE SSize_t CPerl_av_len(pTHX_ AV *_Nonnull av) {
	return av_len(av);
}
#endif

#ifdef av_make
/// Creates a new AV and populates it with a list of SVs.  The SVs are copied
/// into the array, so they may be freed after the call to @c av_make.  The new AV
/// will have a reference count of 1.
///
/// Perl equivalent: @c my @c @@new_array @c = @c ($scalar1, @c $scalar2, @c $scalar3...);
SWIFT_NAME(PerlInterpreter.av_make(self:_:_:))
PERL_STATIC_INLINE AV *_Nonnull CPerl_av_make(pTHX_ SSize_t size, SV *_Nonnull *_Nonnull strp) {
	return av_make(size, strp);
}
#endif

#ifdef av_pop
/// Removes one SV from the end of the array, reducing its size by one and
/// returning the SV (transferring control of one reference count) to the
/// caller.  Returns @c &PL_sv_undef if the array is empty.
///
/// Perl equivalent: @c pop(@@myarray);
SWIFT_NAME(PerlInterpreter.av_pop(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_av_pop(pTHX_ AV *_Nonnull av) {
	return av_pop(av);
}
#endif

#ifdef av_push
/// Pushes an SV (transferring control of one reference count) onto the end of the
/// array.  The array will grow automatically to accommodate the addition.
///
/// Perl equivalent: @c push @c @@myarray, @c $val;.
SWIFT_NAME(PerlInterpreter.av_push(self:_:_:))
PERL_STATIC_INLINE void CPerl_av_push(pTHX_ AV *_Nonnull av, SV *_Nonnull val) {
	av_push(av, val);
}
#endif

#ifdef av_shift
/// Removes one SV from the start of the array, reducing its size by one and
/// returning the SV (transferring control of one reference count) to the
/// caller.  Returns @c &PL_sv_undef if the array is empty.
///
/// Perl equivalent: @c shift(@@myarray);
SWIFT_NAME(PerlInterpreter.av_shift(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_av_shift(pTHX_ AV *_Nonnull av) {
	return av_shift(av);
}
#endif

#ifdef av_store
/// Stores an SV in an array.  The array index is specified as @c key.  The
/// return value will be @c NULL if the operation failed or if the value did not
/// need to be actually stored within the array (as in the case of tied
/// arrays).  Otherwise, it can be dereferenced
/// to get the @c SV* that was stored
/// there (= @c val)).
///
/// Note that the caller is responsible for suitably incrementing the reference
/// count of @c val before the call, and decrementing it if the function
/// returned @c NULL.
///
/// Approximate Perl equivalent: @c splice(@@myarray, @c $key, @c 1, @c $val).
///
/// See "Understanding the Magic of Tied Hashes and Arrays" in perlguts for
/// more information on how to use this function on tied arrays.
SWIFT_NAME(PerlInterpreter.av_store(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nullable *_Nullable CPerl_av_store(pTHX_ AV *_Nonnull av, SSize_t key, SV *_Nullable val) {
	return av_store(av, key, val);
}
#endif

#ifdef av_tindex
/// Same as @c av_top_index().
SWIFT_NAME(PerlInterpreter.av_tindex(self:_:))
PERL_STATIC_INLINE SSize_t CPerl_av_tindex(pTHX_ AV *_Nonnull av) {
	return av_tindex(av);
}
#endif

#ifdef av_top_index
/// Returns the highest index in the array.  The number of elements in the
/// array is @c av_top_index(av) @c + @c 1.  Returns -1 if the array is empty.
///
/// The Perl equivalent for this is @c $#myarray.
///
/// (A slightly shorter form is @c av_tindex.)
SWIFT_NAME(PerlInterpreter.av_top_index(self:_:))
PERL_STATIC_INLINE SSize_t CPerl_av_top_index(pTHX_ AV *_Nonnull av) {
	return av_top_index(av);
}
#endif

#ifdef av_undef
/// Undefines the array. The XS equivalent of @c undef(@@array).
///
/// As well as freeing all the elements of the array (like @c av_clear()), this
/// also frees the memory used by the av to store its list of scalars.
///
/// See av_clear for a note about the array possibly being invalid on
/// return.
SWIFT_NAME(PerlInterpreter.av_undef(self:_:))
PERL_STATIC_INLINE void CPerl_av_undef(pTHX_ AV *_Nonnull av) {
	av_undef(av);
}
#endif

#ifdef av_unshift
/// Unshift the given number of @c undef values onto the beginning of the
/// array.  The array will grow automatically to accommodate the addition.
///
/// Perl equivalent: @c unshift @c @@myarray, @c ((undef) @c x @c $num);
SWIFT_NAME(PerlInterpreter.av_unshift(self:_:_:))
PERL_STATIC_INLINE void CPerl_av_unshift(pTHX_ AV *_Nonnull av, SSize_t num) {
	av_unshift(av, num);
}
#endif

#ifdef block_start
/// Handles compile-time scope entry.
/// Arranges for hints to be restored on block
/// exit and also handles pad sequence numbers to make lexical variables scope
/// right.  Returns a savestack index for use with @c block_end.
SWIFT_NAME(PerlInterpreter.block_start(self:_:))
PERL_STATIC_INLINE int CPerl_block_start(pTHX_ int full) {
	return block_start(full);
}
#endif

#ifdef bytes_cmp_utf8
/// Compares the sequence of characters (stored as octets) in @c b, @c blen with the
/// sequence of characters (stored as UTF-8)
/// in @c u, @c ulen.  Returns 0 if they are
/// equal, -1 or -2 if the first string is less than the second string, +1 or +2
/// if the first string is greater than the second string.
///
/// -1 or +1 is returned if the shorter string was identical to the start of the
/// longer string.  -2 or +2 is returned if
/// there was a difference between characters
/// within the strings.
SWIFT_NAME(PerlInterpreter.bytes_cmp_utf8(self:_:_:_:_:))
PERL_STATIC_INLINE int CPerl_bytes_cmp_utf8(pTHX_ const U8 *_Nonnull b, STRLEN blen, const U8 *_Nonnull u, STRLEN ulen) {
	return bytes_cmp_utf8(b, blen, u, ulen);
}
#endif

#ifdef call_argv
/// Performs a callback to the specified named and package-scoped Perl subroutine
/// with @c argv (a @c NULL-terminated array of strings) as arguments.  See
/// perlcall.
///
/// Approximate Perl equivalent: @c &{"$sub_name"}(@@$argv).
SWIFT_NAME(PerlInterpreter.call_argv(self:_:_:_:))
PERL_STATIC_INLINE I32 CPerl_call_argv(pTHX_ const char* _Nonnull sub_name, I32 flags, char*_Nonnull * _Nonnull argv) {
	return call_argv(sub_name, flags, argv);
}
#endif

#ifdef call_method
/// Performs a callback to the specified Perl method.  The blessed object must
/// be on the stack.  See perlcall.
SWIFT_NAME(PerlInterpreter.call_method(self:_:_:))
PERL_STATIC_INLINE I32 CPerl_call_method(pTHX_ const char* _Nonnull methname, I32 flags) {
	return call_method(methname, flags);
}
#endif

#ifdef call_pv
/// Performs a callback to the specified Perl sub.  See perlcall.
SWIFT_NAME(PerlInterpreter.call_pv(self:_:_:))
PERL_STATIC_INLINE I32 CPerl_call_pv(pTHX_ const char* _Nonnull sub_name, I32 flags) {
	return call_pv(sub_name, flags);
}
#endif

#ifdef call_sv
/// Performs a callback to the Perl sub specified by the SV.
///
/// If neither the @c G_METHOD nor @c G_METHOD_NAMED flag is supplied, the
/// SV may be any of a CV, a GV, a reference to a CV, a reference to a GV
/// or @c SvPV(sv) will be used as the name of the sub to call.
///
/// If the @c G_METHOD flag is supplied, the SV may be a reference to a CV or
/// @c SvPV(sv) will be used as the name of the method to call.
///
/// If the @c G_METHOD_NAMED flag is supplied, @c SvPV(sv) will be used as
/// the name of the method to call.
///
/// Some other values are treated specially for internal use and should
/// not be depended on.
///
/// See perlcall.
SWIFT_NAME(PerlInterpreter.call_sv(self:_:_:))
PERL_STATIC_INLINE I32 CPerl_call_sv(pTHX_ SV* _Nonnull sv, VOL I32 flags) {
	return call_sv(sv, flags);
}
#endif

#ifdef croak_no_modify
/// Exactly equivalent to @c Perl_croak(aTHX_ @c "%s", @c PL_no_modify), but generates
/// terser object code than using @c Perl_croak.  Less code used on exception code
/// paths reduces CPU cache pressure.
SWIFT_NAME(croak_no_modify())
PERL_STATIC_INLINE void CPerl_croak_no_modify(void) {
	croak_no_modify();
}
#endif

#ifdef croak_xs_usage
/// A specialised variant of @c croak() for emitting the usage message for xsubs
///
/// @code
/// croak_xs_usage(cv, "eee_yow");
/// @endcode
///
/// works out the package name and subroutine name from @c cv, and then calls
/// @c croak().  Hence if @c cv is @c &ouch::awk, it would call @c croak as:
///
/// @code
/// Perl_croak(aTHX_ "Usage: %" SVf "::%" SVf "(%s)", "ouch" "awk",
///                                                     "eee_yow");
/// @endcode
SWIFT_NAME(PerlInterpreter.croak_xs_usage(self:_:_:))
PERL_STATIC_INLINE void CPerl_croak_xs_usage(pTHX_ const CV *_Nonnull const cv, const char *_Nonnull const params) {
	croak_xs_usage(cv, params);
}
#endif

#ifdef cv_name
/// Returns an SV containing the name of the CV, mainly for use in error
/// reporting.  The CV may actually be a GV instead, in which case the returned
/// SV holds the GV's name.  Anything other than a GV or CV is treated as a
/// string already holding the sub name, but this could change in the future.
///
/// An SV may be passed as a second argument.  If so, the name will be assigned
/// to it and it will be returned.  Otherwise the returned SV will be a new
/// mortal.
///
/// If @c flags has the @c CV_NAME_NOTQUAL bit set, then the package name will not be
/// included.  If the first argument is neither a CV nor a GV, this flag is
/// ignored (subject to change).
SWIFT_NAME(PerlInterpreter.cv_name(self:_:_:_:))
PERL_STATIC_INLINE SV  *_Nonnull CPerl_cv_name(pTHX_ CV *_Nonnull cv, SV *_Nullable sv, U32 flags) {
	return cv_name(cv, sv, flags);
}
#endif

#ifdef cv_undef
/// Clear out all the active components of a CV.  This can happen either
/// by an explicit @c undef @c &foo, or by the reference count going to zero.
/// In the former case, we keep the @c CvOUTSIDE pointer, so that any anonymous
/// children can still follow the full lexical scope chain.
SWIFT_NAME(PerlInterpreter.cv_undef(self:_:))
PERL_STATIC_INLINE void CPerl_cv_undef(pTHX_ CV* _Nonnull cv) {
	cv_undef(cv);
}
#endif

#ifdef eval_sv
/// Tells Perl to @c eval the string in the SV.  It supports the same flags
/// as @c call_sv, with the obvious exception of @c G_EVAL.  See perlcall.
SWIFT_NAME(PerlInterpreter.eval_sv(self:_:_:))
PERL_STATIC_INLINE I32 CPerl_eval_sv(pTHX_ SV* _Nonnull sv, I32 flags) {
	return eval_sv(sv, flags);
}
#endif

#ifdef fbm_compile
/// Analyses the string in order to make fast searches on it using @c fbm_instr()
/// -- the Boyer-Moore algorithm.
SWIFT_NAME(PerlInterpreter.fbm_compile(self:_:_:))
PERL_STATIC_INLINE void CPerl_fbm_compile(pTHX_ SV* _Nonnull sv, U32 flags) {
	fbm_compile(sv, flags);
}
#endif

#ifdef foldEQ_utf8
/// Returns true if the leading portions of the strings @c s1 and @c s2 (either or both
/// of which may be in UTF-8) are the same case-insensitively; false otherwise.
/// How far into the strings to compare is determined by other input parameters.
///
/// If @c u1 is true, the string @c s1 is assumed to be in UTF-8-encoded Unicode;
/// otherwise it is assumed to be in native 8-bit encoding.  Correspondingly for @c u2
/// with respect to @c s2.
///
/// If the byte length @c l1 is non-zero, it says how far into @c s1 to check for fold
/// equality.  In other words, @c s1+@c l1 will be used as a goal to reach.  The
/// scan will not be considered to be a match unless the goal is reached, and
/// scanning won't continue past that goal.  Correspondingly for @c l2 with respect to
/// @c s2.
///
/// If @c pe1 is non-@c NULL and the pointer it points to is not @c NULL, that pointer is
/// considered an end pointer to the position 1 byte past the maximum point
/// in @c s1 beyond which scanning will not continue under any circumstances.
/// (This routine assumes that UTF-8 encoded input strings are not malformed;
/// malformed input can cause it to read past @c pe1).
/// This means that if both @c l1 and @c pe1 are specified, and @c pe1
/// is less than @c s1+@c l1, the match will never be successful because it can
/// never
/// get as far as its goal (and in fact is asserted against).  Correspondingly for
/// @c pe2 with respect to @c s2.
///
/// At least one of @c s1 and @c s2 must have a goal (at least one of @c l1 and
/// @c l2 must be non-zero), and if both do, both have to be
/// reached for a successful match.   Also, if the fold of a character is multiple
/// characters, all of them must be matched (see tr21 reference below for
/// 'folding').
///
/// Upon a successful match, if @c pe1 is non-@c NULL,
/// it will be set to point to the beginning of the @i next character of @c s1
/// beyond what was matched.  Correspondingly for @c pe2 and @c s2.
///
/// For case-insensitiveness, the "casefolding" of Unicode is used
/// instead of upper/lowercasing both the characters, see
/// /www.unicode.org/unicode/reports/tr21/ in http: (Case Mappings).
SWIFT_NAME(PerlInterpreter.foldEQ_utf8(self:_:_:_:_:_:_:_:_:))
PERL_STATIC_INLINE I32 CPerl_foldEQ_utf8(pTHX_ const char *_Nonnull s1, char *_Nullable *_Nullable pe1, UV l1, bool u1, const char *_Nonnull s2, char *_Nullable *_Nullable pe2, UV l2, bool u2) {
	return foldEQ_utf8(s1, pe1, l1, u1, s2, pe2, l2, u2);
}
#endif

#ifdef get_av
/// Returns the AV of the specified Perl global or package array with the given
/// name (so it won't work on lexical variables).  @c flags are passed
/// to @c gv_fetchpv.  If @c GV_ADD is set and the
/// Perl variable does not exist then it will be created.  If @c flags is zero
/// and the variable does not exist then NULL is returned.
///
/// Perl equivalent: @c @@{"$name"}.
SWIFT_NAME(PerlInterpreter.get_av(self:_:_:))
PERL_STATIC_INLINE AV *_Nullable CPerl_get_av(pTHX_ const char *_Nonnull name, I32 flags) {
	return get_av(name, flags);
}
#endif

#ifdef get_cv
/// Uses @c strlen to get the length of @c name, then calls @c get_cvn_flags.
SWIFT_NAME(PerlInterpreter.get_cv(self:_:_:))
PERL_STATIC_INLINE CV *_Nullable CPerl_get_cv(pTHX_ const char* _Nonnull name, I32 flags) {
	return get_cv(name, flags);
}
#endif

#ifdef get_hv
/// Returns the HV of the specified Perl hash.  @c flags are passed to
/// @c gv_fetchpv.  If @c GV_ADD is set and the
/// Perl variable does not exist then it will be created.  If @c flags is zero
/// and the variable does not exist then @c NULL is returned.
SWIFT_NAME(PerlInterpreter.get_hv(self:_:_:))
PERL_STATIC_INLINE HV *_Nullable CPerl_get_hv(pTHX_ const char *_Nonnull name, I32 flags) {
	return get_hv(name, flags);
}
#endif

#ifdef get_sv
/// Returns the SV of the specified Perl scalar.  @c flags are passed to
/// @c gv_fetchpv.  If @c GV_ADD is set and the
/// Perl variable does not exist then it will be created.  If @c flags is zero
/// and the variable does not exist then NULL is returned.
SWIFT_NAME(PerlInterpreter.get_sv(self:_:_:))
PERL_STATIC_INLINE SV *_Nullable CPerl_get_sv(pTHX_ const char *_Nonnull name, I32 flags) {
	return get_sv(name, flags);
}
#endif

#ifdef getcwd_sv
/// Fill @c sv with current working directory
SWIFT_NAME(PerlInterpreter.getcwd_sv(self:_:))
PERL_STATIC_INLINE int CPerl_getcwd_sv(pTHX_ SV* _Nonnull sv) {
	return getcwd_sv(sv);
}
#endif

#ifdef grok_bin
/// converts a string representing a binary number to numeric form.
///
/// On entry @c start and @c *len give the string to scan, @c *flags gives
/// conversion flags, and @c result should be @c NULL or a pointer to an NV.
/// The scan stops at the end of the string, or the first invalid character.
/// Unless @c PERL_SCAN_SILENT_ILLDIGIT is set in @c *flags, encountering an
/// invalid character will also trigger a warning.
/// On return @c *len is set to the length of the scanned string,
/// and @c *flags gives output flags.
///
/// If the value is <= @c UV_MAX it is returned as a UV, the output flags are clear,
/// and nothing is written to @c *result.  If the value is > @c UV_MAX, @c grok_bin
/// returns @c UV_MAX, sets @c PERL_SCAN_GREATER_THAN_UV_MAX in the output flags,
/// and writes the value to @c *result (or the value is discarded if @c result
/// is NULL).
///
/// The binary number may optionally be prefixed with @c "0b" or @c "b" unless
/// @c PERL_SCAN_DISALLOW_PREFIX is set in @c *flags on entry.  If
/// @c PERL_SCAN_ALLOW_UNDERSCORES is set in @c *flags then the binary
/// number may use @c "_" characters to separate digits.
SWIFT_NAME(PerlInterpreter.grok_bin(self:_:_:_:_:))
PERL_STATIC_INLINE UV CPerl_grok_bin(pTHX_ const char* _Nonnull start, STRLEN* _Nonnull len_p, I32* _Nonnull flags, NV *_Nullable result) {
	return grok_bin(start, len_p, flags, result);
}
#endif

#ifdef grok_hex
/// converts a string representing a hex number to numeric form.
///
/// On entry @c start and @c *len_p give the string to scan, @c *flags gives
/// conversion flags, and @c result should be @c NULL or a pointer to an NV.
/// The scan stops at the end of the string, or the first invalid character.
/// Unless @c PERL_SCAN_SILENT_ILLDIGIT is set in @c *flags, encountering an
/// invalid character will also trigger a warning.
/// On return @c *len is set to the length of the scanned string,
/// and @c *flags gives output flags.
///
/// If the value is <= @c UV_MAX it is returned as a UV, the output flags are clear,
/// and nothing is written to @c *result.  If the value is > @c UV_MAX, @c grok_hex
/// returns @c UV_MAX, sets @c PERL_SCAN_GREATER_THAN_UV_MAX in the output flags,
/// and writes the value to @c *result (or the value is discarded if @c result
/// is @c NULL).
///
/// The hex number may optionally be prefixed with @c "0x" or @c "x" unless
/// @c PERL_SCAN_DISALLOW_PREFIX is set in @c *flags on entry.  If
/// @c PERL_SCAN_ALLOW_UNDERSCORES is set in @c *flags then the hex
/// number may use @c "_" characters to separate digits.
SWIFT_NAME(PerlInterpreter.grok_hex(self:_:_:_:_:))
PERL_STATIC_INLINE UV CPerl_grok_hex(pTHX_ const char* _Nonnull start, STRLEN* _Nonnull len_p, I32* _Nonnull flags, NV *_Nullable result) {
	return grok_hex(start, len_p, flags, result);
}
#endif

#ifdef grok_infnan
/// Helper for @c grok_number(), accepts various ways of spelling "infinity"
/// or "not a number", and returns one of the following flag combinations:
///
/// @code
/// IS_NUMBER_INFINITE
/// IS_NUMBER_NAN
/// IS_NUMBER_INFINITE | IS_NUMBER_NEG
/// IS_NUMBER_NAN | IS_NUMBER_NEG
/// 0
/// @endcode
///
/// possibly |-ed with @c IS_NUMBER_TRAILING.
///
/// If an infinity or a not-a-number is recognized, @c *sp will point to
/// one byte past the end of the recognized string.  If the recognition fails,
/// zero is returned, and @c *sp will not move.
SWIFT_NAME(PerlInterpreter.grok_infnan(self:_:_:))
PERL_STATIC_INLINE int CPerl_grok_infnan(pTHX_ const char*_Nonnull * _Nonnull sp, const char *_Nonnull send) {
	return grok_infnan(sp, send);
}
#endif

#ifdef grok_number
/// Identical to @c grok_number_flags() with @c flags set to zero.
SWIFT_NAME(PerlInterpreter.grok_number(self:_:_:_:))
PERL_STATIC_INLINE int CPerl_grok_number(pTHX_ const char *_Nonnull pv, STRLEN len, UV *_Nullable valuep) {
	return grok_number(pv, len, valuep);
}
#endif

#ifdef grok_number_flags
/// Recognise (or not) a number.  The type of the number is returned
/// (0 if unrecognised), otherwise it is a bit-ORed combination of
/// @c IS_NUMBER_IN_UV, @c IS_NUMBER_GREATER_THAN_UV_MAX, @c IS_NUMBER_NOT_INT,
/// @c IS_NUMBER_NEG, @c IS_NUMBER_INFINITY, @c IS_NUMBER_NAN (defined in perl.h).
///
/// If the value of the number can fit in a UV, it is returned in @c *valuep.
/// @c IS_NUMBER_IN_UV will be set to indicate that @c *valuep is valid, @c IS_NUMBER_IN_UV
/// will never be set unless @c *valuep is valid, but @c *valuep may have been assigned
/// to during processing even though @c IS_NUMBER_IN_UV is not set on return.
/// If @c valuep is @c NULL, @c IS_NUMBER_IN_UV will be set for the same cases as when
/// @c valuep is non-@c NULL, but no actual assignment (or SEGV) will occur.
///
/// @c IS_NUMBER_NOT_INT will be set with @c IS_NUMBER_IN_UV if trailing decimals were
/// seen (in which case @c *valuep gives the true value truncated to an integer), and
/// @c IS_NUMBER_NEG if the number is negative (in which case @c *valuep holds the
/// absolute value).  @c IS_NUMBER_IN_UV is not set if e notation was used or the
/// number is larger than a UV.
///
/// @c flags allows only @c PERL_SCAN_TRAILING, which allows for trailing
/// non-numeric text on an otherwise successful @i grok, setting
/// @c IS_NUMBER_TRAILING on the result.
SWIFT_NAME(PerlInterpreter.grok_number_flags(self:_:_:_:_:))
PERL_STATIC_INLINE int CPerl_grok_number_flags(pTHX_ const char *_Nonnull pv, STRLEN len, UV *_Nullable valuep, U32 flags) {
	return grok_number_flags(pv, len, valuep, flags);
}
#endif

#ifdef grok_numeric_radix
/// Scan and skip for a numeric decimal separator (radix).
SWIFT_NAME(PerlInterpreter.grok_numeric_radix(self:_:_:))
PERL_STATIC_INLINE bool CPerl_grok_numeric_radix(pTHX_ const char *_Nonnull *_Nonnull sp, const char *_Nonnull send) {
	return grok_numeric_radix(sp, send);
}
#endif

#ifdef grok_oct
/// converts a string representing an octal number to numeric form.
///
/// On entry @c start and @c *len give the string to scan, @c *flags gives
/// conversion flags, and @c result should be @c NULL or a pointer to an NV.
/// The scan stops at the end of the string, or the first invalid character.
/// Unless @c PERL_SCAN_SILENT_ILLDIGIT is set in @c *flags, encountering an
/// 8 or 9 will also trigger a warning.
/// On return @c *len is set to the length of the scanned string,
/// and @c *flags gives output flags.
///
/// If the value is <= @c UV_MAX it is returned as a UV, the output flags are clear,
/// and nothing is written to @c *result.  If the value is > @c UV_MAX, @c grok_oct
/// returns @c UV_MAX, sets @c PERL_SCAN_GREATER_THAN_UV_MAX in the output flags,
/// and writes the value to @c *result (or the value is discarded if @c result
/// is @c NULL).
///
/// If @c PERL_SCAN_ALLOW_UNDERSCORES is set in @c *flags then the octal
/// number may use @c "_" characters to separate digits.
SWIFT_NAME(PerlInterpreter.grok_oct(self:_:_:_:_:))
PERL_STATIC_INLINE UV CPerl_grok_oct(pTHX_ const char* _Nonnull start, STRLEN* _Nonnull len_p, I32* _Nonnull flags, NV *_Nullable result) {
	return grok_oct(start, len_p, flags, result);
}
#endif

#ifdef gv_init
/// The old form of @c gv_init_pvn().  It does not work with UTF-8 strings, as it
/// has no flags parameter.  If the @c multi parameter is set, the
/// @c GV_ADDMULTI flag will be passed to @c gv_init_pvn().
SWIFT_NAME(PerlInterpreter.gv_init(self:_:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_gv_init(pTHX_ GV* _Nonnull gv, HV* _Nullable stash, const char* _Nonnull name, STRLEN len, bool multi) {
	gv_init(gv, stash, name, len, multi);
}
#endif

#ifdef hv_clear
/// Frees the all the elements of a hash, leaving it empty.
/// The XS equivalent of @c %hash @c = @c ().  See also hv_undef.
///
/// See av_clear for a note about the hash possibly being invalid on
/// return.
SWIFT_NAME(PerlInterpreter.hv_clear(self:_:))
PERL_STATIC_INLINE void CPerl_hv_clear(pTHX_ HV *_Nullable hv) {
	hv_clear(hv);
}
#endif

#ifdef hv_clear_placeholders
/// Clears any placeholders from a hash.  If a restricted hash has any of its keys
/// marked as readonly and the key is subsequently deleted, the key is not actually
/// deleted but is marked by assigning it a value of @c &PL_sv_placeholder.  This tags
/// it so it will be ignored by future operations such as iterating over the hash,
/// but will still allow the hash to have a value reassigned to the key at some
/// future point.  This function clears any such placeholder keys from the hash.
/// See @c lock_keys @c in @c Hash::Util::lock_keys()|Hash::Util for an example of its
/// use.
SWIFT_NAME(PerlInterpreter.hv_clear_placeholders(self:_:))
PERL_STATIC_INLINE void CPerl_hv_clear_placeholders(pTHX_ HV *_Nonnull hv) {
	hv_clear_placeholders(hv);
}
#endif

#ifdef hv_delete
/// Deletes a key/value pair in the hash.  The value's SV is removed from
/// the hash, made mortal, and returned to the caller.  The absolute
/// value of @c klen is the length of the key.  If @c klen is negative the
/// key is assumed to be in UTF-8-encoded Unicode.  The @c flags value
/// will normally be zero; if set to @c G_DISCARD then @c NULL will be returned.
/// @c NULL will also be returned if the key is not found.
SWIFT_NAME(PerlInterpreter.hv_delete(self:_:_:_:_:))
PERL_STATIC_INLINE SV *_Nullable CPerl_hv_delete(pTHX_ HV *_Nullable hv, const char *_Nonnull key, I32 klen, I32 flags) {
	return hv_delete(hv, key, klen, flags);
}
#endif

#ifdef hv_delete_ent
/// Deletes a key/value pair in the hash.  The value SV is removed from the hash,
/// made mortal, and returned to the caller.  The @c flags value will normally be
/// zero; if set to @c G_DISCARD then @c NULL will be returned.  @c NULL will also
/// be returned if the key is not found.  @c hash can be a valid precomputed hash
/// value, or 0 to ask for it to be computed.
SWIFT_NAME(PerlInterpreter.hv_delete_ent(self:_:_:_:_:))
PERL_STATIC_INLINE SV *_Nullable CPerl_hv_delete_ent(pTHX_ HV *_Nullable hv, SV *_Nonnull keysv, I32 flags, U32 hash) {
	return hv_delete_ent(hv, keysv, flags, hash);
}
#endif

#ifdef hv_exists
/// Returns a boolean indicating whether the specified hash key exists.  The
/// absolute value of @c klen is the length of the key.  If @c klen is
/// negative the key is assumed to be in UTF-8-encoded Unicode.
SWIFT_NAME(PerlInterpreter.hv_exists(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_hv_exists(pTHX_ HV *_Nullable hv, const char *_Nonnull key, I32 klen) {
	return hv_exists(hv, key, klen);
}
#endif

#ifdef hv_exists_ent
/// Returns a boolean indicating whether
/// the specified hash key exists.  @c hash
/// can be a valid precomputed hash value, or 0 to ask for it to be
/// computed.
SWIFT_NAME(PerlInterpreter.hv_exists_ent(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_hv_exists_ent(pTHX_ HV *_Nullable hv, SV *_Nonnull keysv, U32 hash) {
	return hv_exists_ent(hv, keysv, hash);
}
#endif

#ifdef hv_fetch
/// Returns the SV which corresponds to the specified key in the hash.
/// The absolute value of @c klen is the length of the key.  If @c klen is
/// negative the key is assumed to be in UTF-8-encoded Unicode.  If
/// @c lval is set then the fetch will be part of a store.  This means that if
/// there is no value in the hash associated with the given key, then one is
/// created and a pointer to it is returned.  The @c SV* it points to can be
/// assigned to.  But always check that the
/// return value is non-null before dereferencing it to an @c SV*.
///
/// See "Understanding the Magic of Tied Hashes and Arrays" in perlguts for more
/// information on how to use this function on tied hashes.
SWIFT_NAME(PerlInterpreter.hv_fetch(self:_:_:_:_:))
PERL_STATIC_INLINE SV *_Nullable *_Nullable CPerl_hv_fetch(pTHX_ HV *_Nullable hv, const char *_Nonnull key, I32 klen, bool lval) {
	return hv_fetch(hv, key, klen, lval);
}
#endif

#ifdef hv_fetch_ent
/// Returns the hash entry which corresponds to the specified key in the hash.
/// @c hash must be a valid precomputed hash number for the given @c key, or 0
/// if you want the function to compute it.  IF @c lval is set then the fetch
/// will be part of a store.  Make sure the return value is non-null before
/// accessing it.  The return value when @c hv is a tied hash is a pointer to a
/// static location, so be sure to make a copy of the structure if you need to
/// store it somewhere.
///
/// See "Understanding the Magic of Tied Hashes and Arrays" in perlguts for more
/// information on how to use this function on tied hashes.
SWIFT_NAME(PerlInterpreter.hv_fetch_ent(self:_:_:_:_:))
PERL_STATIC_INLINE HE *_Nullable CPerl_hv_fetch_ent(pTHX_ HV *_Nullable hv, SV *_Nonnull keysv, bool lval, U32 hash) {
	return hv_fetch_ent(hv, keysv, lval, hash);
}
#endif

#ifdef hv_iterinit
/// Prepares a starting point to traverse a hash table.  Returns the number of
/// keys in the hash, including placeholders (i.e. the same as @c HvTOTALKEYS(hv)).
/// The return value is currently only meaningful for hashes without tie magic.
///
/// NOTE: Before version 5.004_65, @c hv_iterinit used to return the number of
/// hash buckets that happen to be in use.  If you still need that esoteric
/// value, you can get it through the macro @c HvFILL(hv).
///
SWIFT_NAME(PerlInterpreter.hv_iterinit(self:_:))
PERL_STATIC_INLINE I32 CPerl_hv_iterinit(pTHX_ HV *_Nonnull hv) {
	return hv_iterinit(hv);
}
#endif

#ifdef hv_iternext
/// Returns entries from a hash iterator.  See @c hv_iterinit.
///
/// You may call @c hv_delete or @c hv_delete_ent on the hash entry that the
/// iterator currently points to, without losing your place or invalidating your
/// iterator.  Note that in this case the current entry is deleted from the hash
/// with your iterator holding the last reference to it.  Your iterator is flagged
/// to free the entry on the next call to @c hv_iternext, so you must not discard
/// your iterator immediately else the entry will leak - call @c hv_iternext to
/// trigger the resource deallocation.
SWIFT_NAME(PerlInterpreter.hv_iternext(self:_:))
PERL_STATIC_INLINE HE *_Nullable CPerl_hv_iternext(pTHX_ HV *_Nonnull hv) {
	return hv_iternext(hv);
}
#endif

#ifdef hv_magic
/// Adds magic to a hash.  See @c sv_magic.
SWIFT_NAME(PerlInterpreter.hv_magic(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_hv_magic(pTHX_ HV *_Nonnull hv, GV *_Nullable gv, int how) {
	hv_magic(hv, gv, how);
}
#endif

#ifdef hv_scalar
/// Evaluates the hash in scalar context and returns the result.
///
/// When the hash is tied dispatches through to the SCALAR method,
/// otherwise returns a mortal SV containing the number of keys
/// in the hash.
///
/// Note, prior to 5.25 this function returned what is now
/// returned by the hv_bucket_ratio() function.
SWIFT_NAME(PerlInterpreter.hv_scalar(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_hv_scalar(pTHX_ HV *_Nonnull hv) {
	return hv_scalar(hv);
}
#endif

#ifdef hv_store
/// Stores an SV in a hash.  The hash key is specified as @c key and the
/// absolute value of @c klen is the length of the key.  If @c klen is
/// negative the key is assumed to be in UTF-8-encoded Unicode.  The
/// @c hash parameter is the precomputed hash value; if it is zero then
/// Perl will compute it.
///
/// The return value will be
/// @c NULL if the operation failed or if the value did not need to be actually
/// stored within the hash (as in the case of tied hashes).  Otherwise it can
/// be dereferenced to get the original @c SV*.  Note that the caller is
/// responsible for suitably incrementing the reference count of @c val before
/// the call, and decrementing it if the function returned @c NULL.  Effectively
/// a successful @c hv_store takes ownership of one reference to @c val.  This is
/// usually what you want; a newly created SV has a reference count of one, so
/// if all your code does is create SVs then store them in a hash, @c hv_store
/// will own the only reference to the new SV, and your code doesn't need to do
/// anything further to tidy up.  @c hv_store is not implemented as a call to
/// @c hv_store_ent, and does not create a temporary SV for the key, so if your
/// key data is not already in SV form then use @c hv_store in preference to
/// @c hv_store_ent.
///
/// See "Understanding the Magic of Tied Hashes and Arrays" in perlguts for more
/// information on how to use this function on tied hashes.
SWIFT_NAME(PerlInterpreter.hv_store(self:_:_:_:_:_:))
PERL_STATIC_INLINE SV *_Nullable *_Nullable CPerl_hv_store(pTHX_ HV *_Nullable hv, const char *_Nullable key, I32 klen, SV *_Nullable val, U32 hash) {
	return hv_store(hv, key, klen, val, hash);
}
#endif

#ifdef hv_store_ent
/// Stores @c val in a hash.  The hash key is specified as @c key.  The @c hash
/// parameter is the precomputed hash value; if it is zero then Perl will
/// compute it.  The return value is the new hash entry so created.  It will be
/// @c NULL if the operation failed or if the value did not need to be actually
/// stored within the hash (as in the case of tied hashes).  Otherwise the
/// contents of the return value can be accessed using the @c He? macros
/// described here.  Note that the caller is responsible for suitably
/// incrementing the reference count of @c val before the call, and
/// decrementing it if the function returned NULL.  Effectively a successful
/// @c hv_store_ent takes ownership of one reference to @c val.  This is
/// usually what you want; a newly created SV has a reference count of one, so
/// if all your code does is create SVs then store them in a hash, @c hv_store
/// will own the only reference to the new SV, and your code doesn't need to do
/// anything further to tidy up.  Note that @c hv_store_ent only reads the @c key;
/// unlike @c val it does not take ownership of it, so maintaining the correct
/// reference count on @c key is entirely the caller's responsibility.  @c hv_store
/// is not implemented as a call to @c hv_store_ent, and does not create a temporary
/// SV for the key, so if your key data is not already in SV form then use
/// @c hv_store in preference to @c hv_store_ent.
///
/// See "Understanding the Magic of Tied Hashes and Arrays" in perlguts for more
/// information on how to use this function on tied hashes.
SWIFT_NAME(PerlInterpreter.hv_store_ent(self:_:_:_:_:))
PERL_STATIC_INLINE HE *_Nullable CPerl_hv_store_ent(pTHX_ HV *_Nullable hv, SV *_Nullable key, SV *_Nullable val, U32 hash) {
	return hv_store_ent(hv, key, val, hash);
}
#endif

#ifdef hv_undef
/// Undefines the hash.  The XS equivalent of @c undef(%hash).
///
/// As well as freeing all the elements of the hash (like @c hv_clear()), this
/// also frees any auxiliary data and storage associated with the hash.
///
/// See av_clear for a note about the hash possibly being invalid on
/// return.
SWIFT_NAME(PerlInterpreter.hv_undef(self:_:))
PERL_STATIC_INLINE void CPerl_hv_undef(pTHX_ HV *_Nullable hv) {
	hv_undef(hv);
}
#endif

#ifdef intro_my
/// "Introduce" @c my variables to visible status.  This is called during parsing
/// at the end of each statement to make lexical variables visible to subsequent
/// statements.
SWIFT_NAME(PerlInterpreter.intro_my(self:))
PERL_STATIC_INLINE U32 CPerl_intro_my(pTHX) {
	return intro_my();
}
#endif

#ifdef is_ascii_string
/// This is a misleadingly-named synonym for is_utf8_invariant_string.
/// On ASCII-ish platforms, the name isn't misleading: the ASCII-range characters
/// are exactly the UTF-8 invariants.  But EBCDIC machines have more invariants
/// than just the ASCII characters, so @c is_utf8_invariant_string is preferred.
SWIFT_NAME(is_ascii_string(_:_:))
PERL_STATIC_INLINE bool CPerl_is_ascii_string(const U8* _Nonnull const s, const STRLEN len) {
	return is_ascii_string(s, len);
}
#endif

#ifdef is_c9strict_utf8_string
/// Returns TRUE if the first @c len bytes of string @c s form a valid
/// UTF-8-encoded string that conforms to
/// /www.unicode.org/versions/corrigendum9.html in Unicode Corrigendum #9|http:;
/// otherwise it returns FALSE.  If @c len is 0, it will be calculated using
/// @c strlen(s) (which means if you use this option, that @c s can't have embedded
/// @c NUL characters and has to have a terminating @c NUL byte).  Note that all
/// characters being ASCII constitute 'a valid UTF-8 string'.
///
/// This function returns FALSE for strings containing any code points above the
/// Unicode max of 0x10FFFF or surrogate code points, but accepts non-character
/// code points per
/// /www.unicode.org/versions/corrigendum9.html in Corrigendum #9|http:.
///
/// See also
/// @c is_utf8_invariant_string,
/// @c is_utf8_string,
/// @c is_utf8_string_flags,
/// @c is_utf8_string_loc,
/// @c is_utf8_string_loc_flags,
/// @c is_utf8_string_loclen,
/// @c is_utf8_string_loclen_flags,
/// @c is_utf8_fixed_width_buf_flags,
/// @c is_utf8_fixed_width_buf_loc_flags,
/// @c is_utf8_fixed_width_buf_loclen_flags,
/// @c is_strict_utf8_string,
/// @c is_strict_utf8_string_loc,
/// @c is_strict_utf8_string_loclen,
/// @c is_c9strict_utf8_string_loc,
/// and
/// @c is_c9strict_utf8_string_loclen.
SWIFT_NAME(is_c9strict_utf8_string(_:_:))
PERL_STATIC_INLINE bool CPerl_is_c9strict_utf8_string(const U8 *_Nonnull s, const STRLEN len) {
	return is_c9strict_utf8_string(s, len);
}
#endif

#ifdef is_c9strict_utf8_string_loc
/// Like @c is_c9strict_utf8_string but stores the location of the failure (in
/// the case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer.
///
/// See also @c is_c9strict_utf8_string_loclen.
SWIFT_NAME(is_c9strict_utf8_string_loc(_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_c9strict_utf8_string_loc(const U8 *_Nonnull s, const STRLEN len, const U8 *_Nonnull *_Nonnull ep) {
	return is_c9strict_utf8_string_loc(s, len, ep);
}
#endif

#ifdef is_c9strict_utf8_string_loclen
/// Like @c is_c9strict_utf8_string but stores the location of the failure (in
/// the case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer, and the number of UTF-8 encoded
/// characters in the @c el pointer.
///
/// See also @c is_c9strict_utf8_string_loc.
SWIFT_NAME(is_c9strict_utf8_string_loclen(_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_c9strict_utf8_string_loclen(const U8 *_Nonnull s, const STRLEN len, const U8 *_Nullable *_Nullable ep, STRLEN *_Nullable el) {
	return is_c9strict_utf8_string_loclen(s, len, ep, el);
}
#endif

#ifdef is_invariant_string
/// This is a somewhat misleadingly-named synonym for is_utf8_invariant_string.
/// @c is_utf8_invariant_string is preferred, as it indicates under what conditions
/// the string is invariant.
SWIFT_NAME(is_invariant_string(_:_:))
PERL_STATIC_INLINE bool CPerl_is_invariant_string(const U8* _Nonnull const s, const STRLEN len) {
	return is_invariant_string(s, len);
}
#endif

#ifdef is_strict_utf8_string
/// Returns TRUE if the first @c len bytes of string @c s form a valid
/// UTF-8-encoded string that is fully interchangeable by any application using
/// Unicode rules; otherwise it returns FALSE.  If @c len is 0, it will be
/// calculated using @c strlen(s) (which means if you use this option, that @c s
/// can't have embedded @c NUL characters and has to have a terminating @c NUL
/// byte).  Note that all characters being ASCII constitute 'a valid UTF-8 string'.
///
/// This function returns FALSE for strings containing any
/// code points above the Unicode max of 0x10FFFF, surrogate code points, or
/// non-character code points.
///
/// See also
/// @c is_utf8_invariant_string,
/// @c is_utf8_string,
/// @c is_utf8_string_flags,
/// @c is_utf8_string_loc,
/// @c is_utf8_string_loc_flags,
/// @c is_utf8_string_loclen,
/// @c is_utf8_string_loclen_flags,
/// @c is_utf8_fixed_width_buf_flags,
/// @c is_utf8_fixed_width_buf_loc_flags,
/// @c is_utf8_fixed_width_buf_loclen_flags,
/// @c is_strict_utf8_string_loc,
/// @c is_strict_utf8_string_loclen,
/// @c is_c9strict_utf8_string,
/// @c is_c9strict_utf8_string_loc,
/// and
/// @c is_c9strict_utf8_string_loclen.
SWIFT_NAME(is_strict_utf8_string(_:_:))
PERL_STATIC_INLINE bool CPerl_is_strict_utf8_string(const U8 *_Nonnull s, const STRLEN len) {
	return is_strict_utf8_string(s, len);
}
#endif

#ifdef is_strict_utf8_string_loc
/// Like @c is_strict_utf8_string but stores the location of the failure (in the
/// case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer.
///
/// See also @c is_strict_utf8_string_loclen.
SWIFT_NAME(is_strict_utf8_string_loc(_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_strict_utf8_string_loc(const U8 *_Nonnull s, const STRLEN len, const U8 *_Nonnull *_Nonnull ep) {
	return is_strict_utf8_string_loc(s, len, ep);
}
#endif

#ifdef is_strict_utf8_string_loclen
/// Like @c is_strict_utf8_string but stores the location of the failure (in the
/// case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer, and the number of UTF-8
/// encoded characters in the @c el pointer.
///
/// See also @c is_strict_utf8_string_loc.
SWIFT_NAME(is_strict_utf8_string_loclen(_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_strict_utf8_string_loclen(const U8 *_Nonnull s, const STRLEN len, const U8 *_Nullable *_Nullable ep, STRLEN *_Nullable el) {
	return is_strict_utf8_string_loclen(s, len, ep, el);
}
#endif

#ifdef is_utf8_char_buf
/// This is identical to the macro isUTF8_CHAR.
SWIFT_NAME(is_utf8_char_buf(_:_:))
PERL_STATIC_INLINE STRLEN CPerl_is_utf8_char_buf(const U8 *_Nonnull buf, const U8 *_Nonnull buf_end) {
	return is_utf8_char_buf(buf, buf_end);
}
#endif

#ifdef is_utf8_fixed_width_buf_flags
/// Returns TRUE if the fixed-width buffer starting at @c s with length @c len
/// is entirely valid UTF-8, subject to the restrictions given by @c flags;
/// otherwise it returns FALSE.
///
/// If @c flags is 0, any well-formed UTF-8, as extended by Perl, is accepted
/// without restriction.  If the final few bytes of the buffer do not form a
/// complete code point, this will return TRUE anyway, provided that
/// @c is_utf8_valid_partial_char_flags returns TRUE for them.
///
/// If @c flags in non-zero, it can be any combination of the
/// @c UTF8_DISALLOW_@i @c foo flags accepted by @c utf8n_to_uvchr, and with the
/// same meanings.
///
/// This function differs from @c is_utf8_string_flags only in that the latter
/// returns FALSE if the final few bytes of the string don't form a complete code
/// point.
SWIFT_NAME(is_utf8_fixed_width_buf_flags(_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_fixed_width_buf_flags(const U8 * _Nonnull const s, const STRLEN len, const U32 flags) {
	return is_utf8_fixed_width_buf_flags(s, len, flags);
}
#endif

#ifdef is_utf8_fixed_width_buf_loc_flags
/// Like @c is_utf8_fixed_width_buf_flags but stores the location of the
/// failure in the @c ep pointer.  If the function returns TRUE, @c *ep will point
/// to the beginning of any partial character at the end of the buffer; if there is
/// no partial character @c *ep will contain @c s+@c len.
///
/// See also @c is_utf8_fixed_width_buf_loclen_flags.
SWIFT_NAME(is_utf8_fixed_width_buf_loc_flags(_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_fixed_width_buf_loc_flags(const U8 * _Nonnull const s, const STRLEN len, const U8 *_Nullable *_Nullable ep, const U32 flags) {
	return is_utf8_fixed_width_buf_loc_flags(s, len, ep, flags);
}
#endif

#ifdef is_utf8_fixed_width_buf_loclen_flags
/// Like @c is_utf8_fixed_width_buf_loc_flags but stores the number of
/// complete, valid characters found in the @c el pointer.
SWIFT_NAME(is_utf8_fixed_width_buf_loclen_flags(_:_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_fixed_width_buf_loclen_flags(const U8 * _Nonnull const s, const STRLEN len, const U8 *_Nullable *_Nullable ep, STRLEN *_Nullable el, const U32 flags) {
	return is_utf8_fixed_width_buf_loclen_flags(s, len, ep, el, flags);
}
#endif

#ifdef is_utf8_invariant_string
/// Returns TRUE if the first @c len bytes of the string @c s are the same
/// regardless of the UTF-8 encoding of the string (or UTF-EBCDIC encoding on
/// EBCDIC machines); otherwise it returns FALSE.  That is, it returns TRUE if they
/// are UTF-8 invariant.  On ASCII-ish machines, all the ASCII characters and only
/// the ASCII characters fit this definition.  On EBCDIC machines, the ASCII-range
/// characters are invariant, but so also are the C1 controls.
///
/// If @c len is 0, it will be calculated using @c strlen(s), (which means if you
/// use this option, that @c s can't have embedded @c NUL characters and has to
/// have a terminating @c NUL byte).
///
/// See also
/// @c is_utf8_string,
/// @c is_utf8_string_flags,
/// @c is_utf8_string_loc,
/// @c is_utf8_string_loc_flags,
/// @c is_utf8_string_loclen,
/// @c is_utf8_string_loclen_flags,
/// @c is_utf8_fixed_width_buf_flags,
/// @c is_utf8_fixed_width_buf_loc_flags,
/// @c is_utf8_fixed_width_buf_loclen_flags,
/// @c is_strict_utf8_string,
/// @c is_strict_utf8_string_loc,
/// @c is_strict_utf8_string_loclen,
/// @c is_c9strict_utf8_string,
/// @c is_c9strict_utf8_string_loc,
/// and
/// @c is_c9strict_utf8_string_loclen.
SWIFT_NAME(is_utf8_invariant_string(_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_invariant_string(const U8* _Nonnull const s, STRLEN const len) {
	return is_utf8_invariant_string(s, len);
}
#endif

#ifdef is_utf8_string
/// Returns TRUE if the first @c len bytes of string @c s form a valid
/// Perl-extended-UTF-8 string; returns FALSE otherwise.  If @c len is 0, it will
/// be calculated using @c strlen(s) (which means if you use this option, that @c s
/// can't have embedded @c NUL characters and has to have a terminating @c NUL
/// byte).  Note that all characters being ASCII constitute 'a valid UTF-8 string'.
///
/// This function considers Perl's extended UTF-8 to be valid.  That means that
/// code points above Unicode, surrogates, and non-character code points are
/// considered valid by this function.  Use @c is_strict_utf8_string,
/// @c is_c9strict_utf8_string, or @c is_utf8_string_flags to restrict what
/// code points are considered valid.
///
/// See also
/// @c is_utf8_invariant_string,
/// @c is_utf8_string_loc,
/// @c is_utf8_string_loclen,
/// @c is_utf8_fixed_width_buf_flags,
/// @c is_utf8_fixed_width_buf_loc_flags,
/// @c is_utf8_fixed_width_buf_loclen_flags,
SWIFT_NAME(PerlInterpreter.is_utf8_string(self:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_string(pTHX_ const U8 *_Nonnull s, const STRLEN len) {
	return is_utf8_string(s, len);
}
#endif

#ifdef is_utf8_string_flags
/// Returns TRUE if the first @c len bytes of string @c s form a valid
/// UTF-8 string, subject to the restrictions imposed by @c flags;
/// returns FALSE otherwise.  If @c len is 0, it will be calculated
/// using @c strlen(s) (which means if you use this option, that @c s can't have
/// embedded @c NUL characters and has to have a terminating @c NUL byte).  Note
/// that all characters being ASCII constitute 'a valid UTF-8 string'.
///
/// If @c flags is 0, this gives the same results as @c is_utf8_string; if
/// @c flags is @c UTF8_DISALLOW_ILLEGAL_INTERCHANGE, this gives the same results
/// as @c is_strict_utf8_string; and if @c flags is
/// @c UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE, this gives the same results as
/// @c is_c9strict_utf8_string.  Otherwise @c flags may be any
/// combination of the @c UTF8_DISALLOW_@i @c foo flags understood by
/// @c utf8n_to_uvchr, with the same meanings.
///
/// See also
/// @c is_utf8_invariant_string,
/// @c is_utf8_string,
/// @c is_utf8_string_loc,
/// @c is_utf8_string_loc_flags,
/// @c is_utf8_string_loclen,
/// @c is_utf8_string_loclen_flags,
/// @c is_utf8_fixed_width_buf_flags,
/// @c is_utf8_fixed_width_buf_loc_flags,
/// @c is_utf8_fixed_width_buf_loclen_flags,
/// @c is_strict_utf8_string,
/// @c is_strict_utf8_string_loc,
/// @c is_strict_utf8_string_loclen,
/// @c is_c9strict_utf8_string,
/// @c is_c9strict_utf8_string_loc,
/// and
/// @c is_c9strict_utf8_string_loclen.
SWIFT_NAME(is_utf8_string_flags(_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_string_flags(const U8 *_Nonnull s, const STRLEN len, const U32 flags) {
	return is_utf8_string_flags(s, len, flags);
}
#endif

#ifdef is_utf8_string_loc
/// Like @c is_utf8_string but stores the location of the failure (in the
/// case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer.
///
/// See also @c is_utf8_string_loclen.
SWIFT_NAME(PerlInterpreter.is_utf8_string_loc(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_string_loc(pTHX_ const U8 *_Nonnull s, const STRLEN len, const U8 *_Nonnull *_Nonnull ep) {
	return is_utf8_string_loc(s, len, ep);
}
#endif

#ifdef is_utf8_string_loc_flags
/// Like @c is_utf8_string_flags but stores the location of the failure (in the
/// case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer.
///
/// See also @c is_utf8_string_loclen_flags.
SWIFT_NAME(is_utf8_string_loc_flags(_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_string_loc_flags(const U8 *_Nonnull s, const STRLEN len, const U8 *_Nonnull *_Nonnull ep, const U32 flags) {
	return is_utf8_string_loc_flags(s, len, ep, flags);
}
#endif

#ifdef is_utf8_string_loclen
/// Like @c is_utf8_string but stores the location of the failure (in the
/// case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer, and the number of UTF-8
/// encoded characters in the @c el pointer.
///
/// See also @c is_utf8_string_loc.
SWIFT_NAME(PerlInterpreter.is_utf8_string_loclen(self:_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_string_loclen(pTHX_ const U8 *_Nonnull s, const STRLEN len, const U8 *_Nullable *_Nullable ep, STRLEN *_Nullable el) {
	return is_utf8_string_loclen(s, len, ep, el);
}
#endif

#ifdef is_utf8_string_loclen_flags
/// Like @c is_utf8_string_flags but stores the location of the failure (in the
/// case of "utf8ness failure") or the location @c s+@c len (in the case of
/// "utf8ness success") in the @c ep pointer, and the number of UTF-8
/// encoded characters in the @c el pointer.
///
/// See also @c is_utf8_string_loc_flags.
SWIFT_NAME(is_utf8_string_loclen_flags(_:_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_string_loclen_flags(const U8 *_Nonnull s, const STRLEN len, const U8 *_Nullable *_Nullable ep, STRLEN *_Nullable el, const U32 flags) {
	return is_utf8_string_loclen_flags(s, len, ep, el, flags);
}
#endif

#ifdef is_utf8_valid_partial_char
/// Returns 0 if the sequence of bytes starting at @c s and looking no further than
/// @c e @c - @c 1 is the UTF-8 encoding, as extended by Perl, for one or more code
/// points.  Otherwise, it returns 1 if there exists at least one non-empty
/// sequence of bytes that when appended to sequence @c s, starting at position
/// @c e causes the entire sequence to be the well-formed UTF-8 of some code point;
/// otherwise returns 0.
///
/// In other words this returns TRUE if @c s points to a partial UTF-8-encoded code
/// point.
///
/// This is useful when a fixed-length buffer is being tested for being well-formed
/// UTF-8, but the final few bytes in it don't comprise a full character; that is,
/// it is split somewhere in the middle of the final code point's UTF-8
/// representation.  (Presumably when the buffer is refreshed with the next chunk
/// of data, the new first bytes will complete the partial code point.)   This
/// function is used to verify that the final bytes in the current buffer are in
/// fact the legal beginning of some code point, so that if they aren't, the
/// failure can be signalled without having to wait for the next read.
SWIFT_NAME(is_utf8_valid_partial_char(_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_valid_partial_char(const U8 * _Nonnull const s, const U8 * _Nonnull const e) {
	return is_utf8_valid_partial_char(s, e);
}
#endif

#ifdef is_utf8_valid_partial_char_flags
/// Like @c is_utf8_valid_partial_char, it returns a boolean giving whether
/// or not the input is a valid UTF-8 encoded partial character, but it takes an
/// extra parameter, @c flags, which can further restrict which code points are
/// considered valid.
///
/// If @c flags is 0, this behaves identically to
/// @c is_utf8_valid_partial_char.  Otherwise @c flags can be any combination
/// of the @c UTF8_DISALLOW_@i @c foo flags accepted by @c utf8n_to_uvchr.  If
/// there is any sequence of bytes that can complete the input partial character in
/// such a way that a non-prohibited character is formed, the function returns
/// TRUE; otherwise FALSE.  Non character code points cannot be determined based on
/// partial character input.  But many  of the other possible excluded types can be
/// determined from just the first one or two bytes.
SWIFT_NAME(is_utf8_valid_partial_char_flags(_:_:_:))
PERL_STATIC_INLINE bool CPerl_is_utf8_valid_partial_char_flags(const U8 * _Nonnull const s, const U8 * _Nonnull const e, const U32 flags) {
	return is_utf8_valid_partial_char_flags(s, e, flags);
}
#endif

#ifdef isinfnan
/// @c Perl_isinfnan() is utility function that returns true if the NV
/// argument is either an infinity or a @c NaN, false otherwise.  To test
/// in more detail, use @c Perl_isinf() and @c Perl_isnan().
///
/// This is also the logical inverse of Perl_isfinite().
SWIFT_NAME(isinfnan(_:))
PERL_STATIC_INLINE bool CPerl_isinfnan(NV nv) {
	return isinfnan(nv);
}
#endif

#ifdef looks_like_number
/// Test if the content of an SV looks like a number (or is a number).
/// @c Inf and @c Infinity are treated as numbers (so will not issue a
/// non-numeric warning), even if your @c atof() doesn't grok them.  Get-magic is
/// ignored.
SWIFT_NAME(PerlInterpreter.looks_like_number(self:_:))
PERL_STATIC_INLINE I32 CPerl_looks_like_number(pTHX_ SV *_Nonnull const sv) {
	return looks_like_number(sv);
}
#endif

#ifdef mg_clear
/// Clear something magical that the SV represents.  See @c sv_magic.
SWIFT_NAME(PerlInterpreter.mg_clear(self:_:))
PERL_STATIC_INLINE int CPerl_mg_clear(pTHX_ SV* _Nonnull sv) {
	return mg_clear(sv);
}
#endif

#ifdef mg_copy
/// Copies the magic from one SV to another.  See @c sv_magic.
SWIFT_NAME(PerlInterpreter.mg_copy(self:_:_:_:_:))
PERL_STATIC_INLINE int CPerl_mg_copy(pTHX_ SV *_Nonnull sv, SV *_Nonnull nsv, const char *_Nullable key, I32 klen) {
	return mg_copy(sv, nsv, key, klen);
}
#endif

#ifdef mg_free
/// Free any magic storage used by the SV.  See @c sv_magic.
SWIFT_NAME(PerlInterpreter.mg_free(self:_:))
PERL_STATIC_INLINE int CPerl_mg_free(pTHX_ SV* _Nonnull sv) {
	return mg_free(sv);
}
#endif

#ifdef mg_free_type
/// Remove any magic of type @c how from the SV @c sv.  See sv_magic.
SWIFT_NAME(PerlInterpreter.mg_free_type(self:_:_:))
PERL_STATIC_INLINE void CPerl_mg_free_type(pTHX_ SV* _Nonnull sv, int how) {
	mg_free_type(sv, how);
}
#endif

#ifdef mg_get
/// Do magic before a value is retrieved from the SV.  The type of SV must
/// be >= @c SVt_PVMG.  See @c sv_magic.
SWIFT_NAME(PerlInterpreter.mg_get(self:_:))
PERL_STATIC_INLINE int CPerl_mg_get(pTHX_ SV* _Nonnull sv) {
	return mg_get(sv);
}
#endif

#ifdef mg_magical
/// Turns on the magical status of an SV.  See @c sv_magic.
SWIFT_NAME(PerlInterpreter.mg_magical(self:_:))
PERL_STATIC_INLINE void CPerl_mg_magical(pTHX_ SV* _Nonnull sv) {
	mg_magical(sv);
}
#endif

#ifdef mg_set
/// Do magic after a value is assigned to the SV.  See @c sv_magic.
SWIFT_NAME(PerlInterpreter.mg_set(self:_:))
PERL_STATIC_INLINE int CPerl_mg_set(pTHX_ SV* _Nonnull sv) {
	return mg_set(sv);
}
#endif

#ifdef mro_method_changed_in
/// Invalidates method caching on any child classes
/// of the given stash, so that they might notice
/// the changes in this one.
///
/// Ideally, all instances of @c PL_sub_generation++ in
/// perl source outside of mro.c should be
/// replaced by calls to this.
///
/// Perl automatically handles most of the common
/// ways a method might be redefined.  However, there
/// are a few ways you could change a method in a stash
/// without the cache code noticing, in which case you
/// need to call this method afterwards:
///
/// 1) Directly manipulating the stash HV entries from
/// XS code.
///
/// 2) Assigning a reference to a readonly scalar
/// constant into a stash entry in order to create
/// a constant subroutine (like constant.pm
/// does).
///
/// This same method is available from pure perl
/// via, @c mro::method_changed_in(classname).
SWIFT_NAME(PerlInterpreter.mro_method_changed_in(self:_:))
PERL_STATIC_INLINE void CPerl_mro_method_changed_in(pTHX_ HV* _Nonnull stash) {
	mro_method_changed_in(stash);
}
#endif

#ifdef newAV
/// Creates a new AV.  The reference count is set to 1.
///
/// Perl equivalent: @c my @c @@array;.
SWIFT_NAME(PerlInterpreter.newAV(self:))
PERL_STATIC_INLINE AV *_Nonnull CPerl_newAV(pTHX) {
	return newAV();
}
#endif

#ifdef newHV
/// Creates a new HV.  The reference count is set to 1.
SWIFT_NAME(PerlInterpreter.newHV(self:))
PERL_STATIC_INLINE HV *_Nonnull CPerl_newHV(pTHX) {
	return newHV();
}
#endif

#ifdef newRV_noinc
/// Creates an RV wrapper for an SV.  The reference count for the original
/// SV is @b not incremented.
SWIFT_NAME(PerlInterpreter.newRV_noinc(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newRV_noinc(pTHX_ SV *_Nonnull const tmpRef) {
	return newRV_noinc(tmpRef);
}
#endif

#ifdef newSV
/// Creates a new SV.  A non-zero @c len parameter indicates the number of
/// bytes of preallocated string space the SV should have.  An extra byte for a
/// trailing @c NUL is also reserved.  (@c SvPOK is not set for the SV even if string
/// space is allocated.)  The reference count for the new SV is set to 1.
///
/// In 5.9.3, @c newSV() replaces the older @c NEWSV() API, and drops the first
/// parameter, @i x, a debug aid which allowed callers to identify themselves.
/// This aid has been superseded by a new build option, @c PERL_MEM_LOG (see
/// PERL_MEM_LOG in perlhacktips).  The older API is still there for use in XS
/// modules supporting older perls.
SWIFT_NAME(PerlInterpreter.newSV(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSV(pTHX_ const STRLEN len) {
	return newSV(len);
}
#endif

#ifdef newSV_type
/// Creates a new SV, of the type specified.  The reference count for the new SV
/// is set to 1.
SWIFT_NAME(PerlInterpreter.newSV_type(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSV_type(pTHX_ const svtype type) {
	return newSV_type(type);
}
#endif

#ifdef newSVhek
/// Creates a new SV from the hash key structure.  It will generate scalars that
/// point to the shared string table where possible.  Returns a new (undefined)
/// SV if @c hek is NULL.
SWIFT_NAME(PerlInterpreter.newSVhek(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSVhek(pTHX_ const HEK *_Nullable const hek) {
	return newSVhek(hek);
}
#endif

#ifdef newSViv
/// Creates a new SV and copies an integer into it.  The reference count for the
/// SV is set to 1.
SWIFT_NAME(PerlInterpreter.newSViv(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSViv(pTHX_ const IV i) {
	return newSViv(i);
}
#endif

#ifdef newSVnv
/// Creates a new SV and copies a floating point value into it.
/// The reference count for the SV is set to 1.
SWIFT_NAME(PerlInterpreter.newSVnv(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSVnv(pTHX_ const NV n) {
	return newSVnv(n);
}
#endif

#ifdef newSVpvn
/// Creates a new SV and copies a string into it, which may contain @c NUL characters
/// (@c \\0) and other binary data.  The reference count for the SV is set to 1.
/// Note that if @c len is zero, Perl will create a zero length (Perl) string.  You
/// are responsible for ensuring that the source buffer is at least
/// @c len bytes long.  If the @c buffer argument is NULL the new SV will be
/// undefined.
SWIFT_NAME(PerlInterpreter.newSVpvn(self:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSVpvn(pTHX_ const char *_Nullable const s, const STRLEN len) {
	return newSVpvn(s, len);
}
#endif

#ifdef newSVpvn_flags
/// Creates a new SV and copies a string (which may contain @c NUL (@c \\0)
/// characters) into it.  The reference count for the
/// SV is set to 1.  Note that if @c len is zero, Perl will create a zero length
/// string.  You are responsible for ensuring that the source string is at least
/// @c len bytes long.  If the @c s argument is NULL the new SV will be undefined.
/// Currently the only flag bits accepted are @c SVf_UTF8 and @c SVs_TEMP.
/// If @c SVs_TEMP is set, then @c sv_2mortal() is called on the result before
/// returning.  If @c SVf_UTF8 is set, @c s
/// is considered to be in UTF-8 and the
/// @c SVf_UTF8 flag will be set on the new SV.
/// @c newSVpvn_utf8() is a convenience wrapper for this function, defined as
///
/// @code
/// #define newSVpvn_utf8(s, len, u)			\\
/// 	newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)
/// @endcode
SWIFT_NAME(PerlInterpreter.newSVpvn_flags(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSVpvn_flags(pTHX_ const char *_Nullable const s, const STRLEN len, const U32 flags) {
	return newSVpvn_flags(s, len, flags);
}
#endif

#ifdef newSVpvn_share
/// Creates a new SV with its @c SvPVX_const pointing to a shared string in the string
/// table.  If the string does not already exist in the table, it is
/// created first.  Turns on the @c SvIsCOW flag (or @c READONLY
/// and @c FAKE in 5.16 and earlier).  If the @c hash parameter
/// is non-zero, that value is used; otherwise the hash is computed.
/// The string's hash can later be retrieved from the SV
/// with the @c SvSHARED_HASH() macro.  The idea here is
/// that as the string table is used for shared hash keys these strings will have
/// @c SvPVX_const @c == @c HeKEY and hash lookup will avoid string compare.
SWIFT_NAME(PerlInterpreter.newSVpvn_share(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSVpvn_share(pTHX_ const char* _Nullable s, I32 len, U32 hash) {
	return newSVpvn_share(s, len, hash);
}
#endif

#ifdef newSVrv
/// Creates a new SV for the existing RV, @c rv, to point to.  If @c rv is not an
/// RV then it will be upgraded to one.  If @c classname is non-null then the new
/// SV will be blessed in the specified package.  The new SV is returned and its
/// reference count is 1.  The reference count 1 is owned by @c rv.
SWIFT_NAME(PerlInterpreter.newSVrv(self:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSVrv(pTHX_ SV *_Nonnull const rv, const char *_Nullable const classname) {
	return newSVrv(rv, classname);
}
#endif

#ifdef newSVsv
/// Creates a new SV which is an exact duplicate of the original SV.
/// (Uses @c sv_setsv.)
SWIFT_NAME(PerlInterpreter.newSVsv(self:_:))
PERL_STATIC_INLINE SV *_Nullable CPerl_newSVsv(pTHX_ SV *_Nullable const old) {
	return newSVsv(old);
}
#endif

#ifdef newSVuv
/// Creates a new SV and copies an unsigned integer into it.
/// The reference count for the SV is set to 1.
SWIFT_NAME(PerlInterpreter.newSVuv(self:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_newSVuv(pTHX_ const UV u) {
	return newSVuv(u);
}
#endif

#ifdef newXS
/// Used by @c xsubpp to hook up XSUBs as Perl subs.  @c filename needs to be
/// static storage, as it is used directly as CvFILE(), without a copy being made.
SWIFT_NAME(PerlInterpreter.newXS(self:_:_:_:))
PERL_STATIC_INLINE CV *_Nonnull CPerl_newXS(pTHX_ const char *_Nullable name, XSUBADDR_t _Nonnull subaddr, const char *_Nonnull filename) {
	return newXS(name, subaddr, filename);
}
#endif

#ifdef newXS_flags
SWIFT_NAME(PerlInterpreter.newXS_flags(self:_:_:_:_:_:))
PERL_STATIC_INLINE CV  *_Nonnull CPerl_newXS_flags(pTHX_ const char *_Nullable name, XSUBADDR_t _Nonnull subaddr, const char *_Nonnull const filename, const char *_Nullable const proto, U32 flags) {
	return newXS_flags(name, subaddr, filename, proto, flags);
}
#endif

#ifdef nothreadhook
/// Stub that provides thread hook for perl_destruct when there are
/// no threads.
SWIFT_NAME(PerlInterpreter.nothreadhook(self:))
PERL_STATIC_INLINE int CPerl_nothreadhook(pTHX) {
	return nothreadhook();
}
#endif

#ifdef op_class
/// Given an op, determine what type of struct it has been allocated as.
/// Returns one of the OPclass enums, such as OPclass_LISTOP.
SWIFT_NAME(PerlInterpreter.op_class(self:_:))
PERL_STATIC_INLINE OPclass CPerl_op_class(pTHX_ const OP *_Nullable o) {
	return op_class(o);
}
#endif

#ifdef op_free
/// Free an op.  Only use this when an op is no longer linked to from any
/// optree.
SWIFT_NAME(PerlInterpreter.op_free(self:_:))
PERL_STATIC_INLINE void CPerl_op_free(pTHX_ OP* _Nullable arg) {
	op_free(arg);
}
#endif

#ifdef op_null
/// Neutralizes an op when it is no longer needed, but is still linked to from
/// other ops.
SWIFT_NAME(PerlInterpreter.op_null(self:_:))
PERL_STATIC_INLINE void CPerl_op_null(pTHX_ OP* _Nonnull o) {
	op_null(o);
}
#endif

#ifdef pack_cat
/// The engine implementing @c pack() Perl function.  Note: parameters
/// @c next_in_list and @c flags are not used.  This call should not be used; use
/// @c packlist instead.
SWIFT_NAME(PerlInterpreter.pack_cat(self:_:_:_:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_pack_cat(pTHX_ SV *_Nonnull cat, const char *_Nonnull pat, const char *_Nonnull patend, SV *_Nonnull *_Nonnull beglist, SV *_Nonnull *_Nonnull endlist, SV *_Nonnull *_Nonnull *_Nonnull next_in_list, U32 flags) {
	pack_cat(cat, pat, patend, beglist, endlist, next_in_list, flags);
}
#endif

#ifdef packlist
/// The engine implementing @c pack() Perl function.
SWIFT_NAME(PerlInterpreter.packlist(self:_:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_packlist(pTHX_ SV *_Nonnull cat, const char *_Nonnull pat, const char *_Nonnull patend, SV *_Nonnull *_Nonnull beglist, SV *_Nonnull *_Nonnull endlist) {
	packlist(cat, pat, patend, beglist, endlist);
}
#endif

#ifdef pad_add_name_pv
/// Exactly like pad_add_name_pvn, but takes a nul-terminated string
/// instead of a string/length pair.
SWIFT_NAME(PerlInterpreter.pad_add_name_pv(self:_:_:_:_:))
PERL_STATIC_INLINE PADOFFSET CPerl_pad_add_name_pv(pTHX_ const char *_Nonnull name, const U32 flags, HV *_Nullable typestash, HV *_Nullable ourstash) {
	return pad_add_name_pv(name, flags, typestash, ourstash);
}
#endif

#ifdef pad_add_name_pvn
/// Allocates a place in the currently-compiling pad for a named lexical
/// variable.  Stores the name and other metadata in the name part of the
/// pad, and makes preparations to manage the variable's lexical scoping.
/// Returns the offset of the allocated pad slot.
///
/// @c namepv/@c namelen specify the variable's name, including leading sigil.
/// If @c typestash is non-null, the name is for a typed lexical, and this
/// identifies the type.  If @c ourstash is non-null, it's a lexical reference
/// to a package variable, and this identifies the package.  The following
/// flags can be OR'ed together:
///
/// @code
/// padadd_OUR          redundantly specifies if it's a package var
/// padadd_STATE        variable will retain value persistently
/// padadd_NO_DUP_CHECK skip check for lexical shadowing
/// @endcode
SWIFT_NAME(PerlInterpreter.pad_add_name_pvn(self:_:_:_:_:_:))
PERL_STATIC_INLINE PADOFFSET CPerl_pad_add_name_pvn(pTHX_ const char *_Nonnull namepv, STRLEN namelen, U32 flags, HV *_Nullable typestash, HV *_Nullable ourstash) {
	return pad_add_name_pvn(namepv, namelen, flags, typestash, ourstash);
}
#endif

#ifdef pad_add_name_sv
/// Exactly like pad_add_name_pvn, but takes the name string in the form
/// of an SV instead of a string/length pair.
SWIFT_NAME(PerlInterpreter.pad_add_name_sv(self:_:_:_:_:))
PERL_STATIC_INLINE PADOFFSET CPerl_pad_add_name_sv(pTHX_ SV *_Nonnull name, U32 flags, HV *_Nullable typestash, HV *_Nullable ourstash) {
	return pad_add_name_sv(name, flags, typestash, ourstash);
}
#endif

#ifdef pad_findmy_pv
/// Exactly like pad_findmy_pvn, but takes a nul-terminated string
/// instead of a string/length pair.
SWIFT_NAME(PerlInterpreter.pad_findmy_pv(self:_:_:))
PERL_STATIC_INLINE PADOFFSET CPerl_pad_findmy_pv(pTHX_ const char* _Nonnull name, U32 flags) {
	return pad_findmy_pv(name, flags);
}
#endif

#ifdef pad_findmy_pvn
/// Given the name of a lexical variable, find its position in the
/// currently-compiling pad.
/// @c namepv/@c namelen specify the variable's name, including leading sigil.
/// @c flags is reserved and must be zero.
/// If it is not in the current pad but appears in the pad of any lexically
/// enclosing scope, then a pseudo-entry for it is added in the current pad.
/// Returns the offset in the current pad,
/// or @c NOT_IN_PAD if no such lexical is in scope.
SWIFT_NAME(PerlInterpreter.pad_findmy_pvn(self:_:_:_:))
PERL_STATIC_INLINE PADOFFSET CPerl_pad_findmy_pvn(pTHX_ const char* _Nonnull namepv, STRLEN namelen, U32 flags) {
	return pad_findmy_pvn(namepv, namelen, flags);
}
#endif

#ifdef pad_findmy_sv
/// Exactly like pad_findmy_pvn, but takes the name string in the form
/// of an SV instead of a string/length pair.
SWIFT_NAME(PerlInterpreter.pad_findmy_sv(self:_:_:))
PERL_STATIC_INLINE PADOFFSET CPerl_pad_findmy_sv(pTHX_ SV* _Nonnull name, U32 flags) {
	return pad_findmy_sv(name, flags);
}
#endif

/// Allocates a new Perl interpreter.  See perlembed.
SWIFT_NAME(PerlInterpreter.alloc())
PERL_STATIC_INLINE PerlInterpreter *_Nullable CPerl_perl_alloc(void) {
	return perl_alloc();
}

/// Initializes a new Perl interpreter.  See perlembed.
SWIFT_NAME(PerlInterpreter.construct(self:))
PERL_STATIC_INLINE void CPerl_perl_construct(PerlInterpreter *_Nonnull my_perl) {
	perl_construct(my_perl);
}

/// Shuts down a Perl interpreter.  See perlembed.
SWIFT_NAME(PerlInterpreter.destruct(self:))
PERL_STATIC_INLINE int CPerl_perl_destruct(PerlInterpreter *_Nonnull my_perl) {
	return perl_destruct(my_perl);
}

/// Releases a Perl interpreter.  See perlembed.
SWIFT_NAME(PerlInterpreter.free(self:))
PERL_STATIC_INLINE void CPerl_perl_free(PerlInterpreter *_Nonnull my_perl) {
	perl_free(my_perl);
}

/// Tells a Perl interpreter to parse a Perl script.  See perlembed.
SWIFT_NAME(PerlInterpreter.parse(self:_:_:_:_:))
PERL_STATIC_INLINE int CPerl_perl_parse(PerlInterpreter *_Nonnull my_perl, XSINIT_t _Nullable xsinit, int argc, char*_Nullable * _Nullable argv, char*_Nullable * _Nullable env) {
	return perl_parse(my_perl, xsinit, argc, argv, env);
}

/// Tells a Perl interpreter to run.  See perlembed.
SWIFT_NAME(PerlInterpreter.run(self:))
PERL_STATIC_INLINE int CPerl_perl_run(PerlInterpreter *_Nonnull my_perl) {
	return perl_run(my_perl);
}

#ifdef require_pv
/// Tells Perl to @c require the file named by the string argument.  It is
/// analogous to the Perl code @c eval @c "require @c '$file'".  It's even
/// implemented that way; consider using load_module instead.
SWIFT_NAME(PerlInterpreter.require_pv(self:_:))
PERL_STATIC_INLINE void CPerl_require_pv(pTHX_ const char* _Nonnull pv) {
	require_pv(pv);
}
#endif

#ifdef save_gp
/// Saves the current GP of gv on the save stack to be restored on scope exit.
///
/// If empty is true, replace the GP with a new GP.
///
/// If empty is false, mark gv with GVf_INTRO so the next reference
/// assigned is localized, which is how @c  @c local @c *foo @c = @c $someref; @c  works.
SWIFT_NAME(PerlInterpreter.save_gp(self:_:_:))
PERL_STATIC_INLINE void CPerl_save_gp(pTHX_ GV* _Nonnull gv, I32 empty) {
	save_gp(gv, empty);
}
#endif

#ifdef scan_bin
/// For backwards compatibility.  Use @c grok_bin instead.
SWIFT_NAME(PerlInterpreter.scan_bin(self:_:_:_:))
PERL_STATIC_INLINE NV CPerl_scan_bin(pTHX_ const char* _Nonnull start, STRLEN len, STRLEN* _Nonnull retlen) {
	return scan_bin(start, len, retlen);
}
#endif

#ifdef scan_hex
/// For backwards compatibility.  Use @c grok_hex instead.
SWIFT_NAME(PerlInterpreter.scan_hex(self:_:_:_:))
PERL_STATIC_INLINE NV CPerl_scan_hex(pTHX_ const char* _Nonnull start, STRLEN len, STRLEN* _Nonnull retlen) {
	return scan_hex(start, len, retlen);
}
#endif

#ifdef scan_oct
/// For backwards compatibility.  Use @c grok_oct instead.
SWIFT_NAME(PerlInterpreter.scan_oct(self:_:_:_:))
PERL_STATIC_INLINE NV CPerl_scan_oct(pTHX_ const char* _Nonnull start, STRLEN len, STRLEN* _Nonnull retlen) {
	return scan_oct(start, len, retlen);
}
#endif

#ifdef setdefout
/// Sets @c PL_defoutgv, the default file handle for output, to the passed in
/// typeglob.  As @c PL_defoutgv "owns" a reference on its typeglob, the reference
/// count of the passed in typeglob is increased by one, and the reference count
/// of the typeglob that @c PL_defoutgv points to is decreased by one.
SWIFT_NAME(PerlInterpreter.setdefout(self:_:))
PERL_STATIC_INLINE void CPerl_setdefout(pTHX_ GV* _Nonnull gv) {
	setdefout(gv);
}
#endif

#ifdef sortsv
/// In-place sort an array of SV pointers with the given comparison routine.
///
/// Currently this always uses mergesort.  See @c sortsv_flags for a more
/// flexible routine.
SWIFT_NAME(PerlInterpreter.sortsv(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sortsv(pTHX_ SV*_Nullable * _Nullable array, size_t num_elts, SVCOMPARE_t _Nonnull cmp) {
	sortsv(array, num_elts, cmp);
}
#endif

#ifdef sortsv_flags
/// In-place sort an array of SV pointers with the given comparison routine,
/// with various SORTf_* flag options.
SWIFT_NAME(PerlInterpreter.sortsv_flags(self:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_sortsv_flags(pTHX_ SV*_Nullable * _Nullable array, size_t num_elts, SVCOMPARE_t _Nonnull cmp, U32 flags) {
	sortsv_flags(array, num_elts, cmp, flags);
}
#endif

#ifdef sv_2bool
/// This macro is only used by @c sv_true() or its macro equivalent, and only if
/// the latter's argument is neither @c SvPOK, @c SvIOK nor @c SvNOK.
/// It calls @c sv_2bool_flags with the @c SV_GMAGIC flag.
SWIFT_NAME(PerlInterpreter.sv_2bool(self:_:))
PERL_STATIC_INLINE bool CPerl_sv_2bool(pTHX_ SV *_Nonnull const sv) {
	return sv_2bool(sv);
}
#endif

#ifdef sv_2bool_flags
/// This function is only used by @c sv_true() and friends,  and only if
/// the latter's argument is neither @c SvPOK, @c SvIOK nor @c SvNOK.  If the flags
/// contain @c SV_GMAGIC, then it does an @c mg_get() first.
///
SWIFT_NAME(PerlInterpreter.sv_2bool_flags(self:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_2bool_flags(pTHX_ SV *_Nonnull sv, I32 flags) {
	return sv_2bool_flags(sv, flags);
}
#endif

#ifdef sv_2iv_flags
/// Return the integer value of an SV, doing any necessary string
/// conversion.  If @c flags has the @c SV_GMAGIC bit set, does an @c mg_get() first.
/// Normally used via the @c SvIV(sv) and @c SvIVx(sv) macros.
SWIFT_NAME(PerlInterpreter.sv_2iv_flags(self:_:_:))
PERL_STATIC_INLINE IV CPerl_sv_2iv_flags(pTHX_ SV *_Nonnull const sv, const I32 flags) {
	return sv_2iv_flags(sv, flags);
}
#endif

#ifdef sv_2mortal
/// Marks an existing SV as mortal.  The SV will be destroyed "soon", either
/// by an explicit call to @c FREETMPS, or by an implicit call at places such as
/// statement boundaries.  @c SvTEMP() is turned on which means that the SV's
/// string buffer can be "stolen" if this SV is copied.  See also
/// @c sv_newmortal and @c sv_mortalcopy.
SWIFT_NAME(PerlInterpreter.sv_2mortal(self:_:))
PERL_STATIC_INLINE SV *_Nullable CPerl_sv_2mortal(pTHX_ SV *_Nullable const sv) {
	return sv_2mortal(sv);
}
#endif

#ifdef sv_2nv_flags
/// Return the num value of an SV, doing any necessary string or integer
/// conversion.  If @c flags has the @c SV_GMAGIC bit set, does an @c mg_get() first.
/// Normally used via the @c SvNV(sv) and @c SvNVx(sv) macros.
SWIFT_NAME(PerlInterpreter.sv_2nv_flags(self:_:_:))
PERL_STATIC_INLINE NV CPerl_sv_2nv_flags(pTHX_ SV *_Nonnull const sv, const I32 flags) {
	return sv_2nv_flags(sv, flags);
}
#endif

#ifdef sv_2uv_flags
/// Return the unsigned integer value of an SV, doing any necessary string
/// conversion.  If @c flags has the @c SV_GMAGIC bit set, does an @c mg_get() first.
/// Normally used via the @c SvUV(sv) and @c SvUVx(sv) macros.
SWIFT_NAME(PerlInterpreter.sv_2uv_flags(self:_:_:))
PERL_STATIC_INLINE UV CPerl_sv_2uv_flags(pTHX_ SV *_Nonnull const sv, const I32 flags) {
	return sv_2uv_flags(sv, flags);
}
#endif

#ifdef sv_backoff
/// Remove any string offset.  You should normally use the @c SvOOK_off macro
/// wrapper instead.
SWIFT_NAME(PerlInterpreter.sv_backoff(self:_:))
PERL_STATIC_INLINE void CPerl_sv_backoff(pTHX_ SV *_Nonnull const sv) {
	sv_backoff(sv);
}
#endif

#ifdef sv_cat_decode
/// @c encoding is assumed to be an @c Encode object, the PV of @c ssv is
/// assumed to be octets in that encoding and decoding the input starts
/// from the position which @c (PV @c + @c *offset) pointed to.  @c dsv will be
/// concatenated with the decoded UTF-8 string from @c ssv.  Decoding will terminate
/// when the string @c tstr appears in decoding output or the input ends on
/// the PV of @c ssv.  The value which @c offset points will be modified
/// to the last input position on @c ssv.
///
/// Returns TRUE if the terminator was found, else returns FALSE.
SWIFT_NAME(PerlInterpreter.sv_cat_decode(self:_:_:_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_cat_decode(pTHX_ SV* _Nonnull dsv, SV *_Nonnull encoding, SV *_Nonnull ssv, int *_Nonnull offset, char* _Nonnull tstr, int tlen) {
	return sv_cat_decode(dsv, encoding, ssv, offset, tstr, tlen);
}
#endif

#ifdef sv_catpv
/// Concatenates the @c NUL-terminated string onto the end of the string which is
/// in the SV.
/// If the SV has the UTF-8 status set, then the bytes appended should be
/// valid UTF-8.  Handles 'get' magic, but not 'set' magic.  See
/// @c sv_catpv_mg.
SWIFT_NAME(PerlInterpreter.sv_catpv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catpv(pTHX_ SV *_Nonnull const sv, const char* _Nullable ptr) {
	sv_catpv(sv, ptr);
}
#endif

#ifdef sv_catpv_flags
/// Concatenates the @c NUL-terminated string onto the end of the string which is
/// in the SV.
/// If the SV has the UTF-8 status set, then the bytes appended should
/// be valid UTF-8.  If @c flags has the @c SV_SMAGIC bit set, will @c mg_set
/// on the modified SV if appropriate.
SWIFT_NAME(PerlInterpreter.sv_catpv_flags(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catpv_flags(pTHX_ SV *_Nonnull dstr, const char *_Nonnull sstr, const I32 flags) {
	sv_catpv_flags(dstr, sstr, flags);
}
#endif

#ifdef sv_catpv_mg
/// Like @c sv_catpv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_catpv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catpv_mg(pTHX_ SV *_Nonnull const sv, const char *_Nullable const ptr) {
	sv_catpv_mg(sv, ptr);
}
#endif

#ifdef sv_catpvn
/// Concatenates the string onto the end of the string which is in the SV.
/// @c len indicates number of bytes to copy.  If the SV has the UTF-8
/// status set, then the bytes appended should be valid UTF-8.
/// Handles 'get' magic, but not 'set' magic.  See @c sv_catpvn_mg.
SWIFT_NAME(PerlInterpreter.sv_catpvn(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catpvn(pTHX_ SV *_Nonnull dsv, const char *_Nonnull sstr, STRLEN len) {
	sv_catpvn(dsv, sstr, len);
}
#endif

#ifdef sv_catpvn_flags
/// Concatenates the string onto the end of the string which is in the SV.  The
/// @c len indicates number of bytes to copy.
///
/// By default, the string appended is assumed to be valid UTF-8 if the SV has
/// the UTF-8 status set, and a string of bytes otherwise.  One can force the
/// appended string to be interpreted as UTF-8 by supplying the @c SV_CATUTF8
/// flag, and as bytes by supplying the @c SV_CATBYTES flag; the SV or the
/// string appended will be upgraded to UTF-8 if necessary.
///
/// If @c flags has the @c SV_SMAGIC bit set, will
/// @c mg_set on @c dsv afterwards if appropriate.
/// @c sv_catpvn and @c sv_catpvn_nomg are implemented
/// in terms of this function.
SWIFT_NAME(PerlInterpreter.sv_catpvn_flags(self:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catpvn_flags(pTHX_ SV *_Nonnull const dstr, const char *_Nonnull sstr, const STRLEN len, const I32 flags) {
	sv_catpvn_flags(dstr, sstr, len, flags);
}
#endif

#ifdef sv_catpvn_mg
/// Like @c sv_catpvn, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_catpvn_mg(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catpvn_mg(pTHX_ SV *_Nonnull sv, const char *_Nonnull ptr, STRLEN len) {
	sv_catpvn_mg(sv, ptr, len);
}
#endif

#ifdef sv_catsv
/// Concatenates the string from SV @c ssv onto the end of the string in SV
/// @c dsv.  If @c ssv is null, does nothing; otherwise modifies only @c dsv.
/// Handles 'get' magic on both SVs, but no 'set' magic.  See @c sv_catsv_mg
/// and @c sv_catsv_nomg.
SWIFT_NAME(PerlInterpreter.sv_catsv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catsv(pTHX_ SV *_Nonnull dstr, SV *_Nullable sstr) {
	sv_catsv(dstr, sstr);
}
#endif

#ifdef sv_catsv_flags
/// Concatenates the string from SV @c ssv onto the end of the string in SV
/// @c dsv.  If @c ssv is null, does nothing; otherwise modifies only @c dsv.
/// If @c flags has the @c SV_GMAGIC bit set, will call @c mg_get on both SVs if
/// appropriate.  If @c flags has the @c SV_SMAGIC bit set, @c mg_set will be called on
/// the modified SV afterward, if appropriate.  @c sv_catsv, @c sv_catsv_nomg,
/// and @c sv_catsv_mg are implemented in terms of this function.
SWIFT_NAME(PerlInterpreter.sv_catsv_flags(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catsv_flags(pTHX_ SV *_Nonnull const dsv, SV *_Nullable const ssv, const I32 flags) {
	sv_catsv_flags(dsv, ssv, flags);
}
#endif

#ifdef sv_catsv_mg
/// Like @c sv_catsv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_catsv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_catsv_mg(pTHX_ SV *_Nonnull dsv, SV *_Nullable ssv) {
	sv_catsv_mg(dsv, ssv);
}
#endif

#ifdef sv_chop
/// Efficient removal of characters from the beginning of the string buffer.
/// @c SvPOK(sv), or at least @c SvPOKp(sv), must be true and @c ptr must be a
/// pointer to somewhere inside the string buffer.  @c ptr becomes the first
/// character of the adjusted string.  Uses the @c OOK hack.  On return, only
/// @c SvPOK(sv) and @c SvPOKp(sv) among the @c OK flags will be true.
///
/// Beware: after this function returns, @c ptr and SvPVX_const(sv) may no longer
/// refer to the same chunk of data.
///
/// The unfortunate similarity of this function's name to that of Perl's @c chop
/// operator is strictly coincidental.  This function works from the left;
/// @c chop works from the right.
SWIFT_NAME(PerlInterpreter.sv_chop(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_chop(pTHX_ SV *_Nonnull const sv, const char *_Nullable const ptr) {
	sv_chop(sv, ptr);
}
#endif

#ifdef sv_clear
/// Clear an SV: call any destructors, free up any memory used by the body,
/// and free the body itself.  The SV's head is @i not freed, although
/// its type is set to all 1's so that it won't inadvertently be assumed
/// to be live during global destruction etc.
/// This function should only be called when @c REFCNT is zero.  Most of the time
/// you'll want to call @c sv_free() (or its macro wrapper @c SvREFCNT_dec)
/// instead.
SWIFT_NAME(PerlInterpreter.sv_clear(self:_:))
PERL_STATIC_INLINE void CPerl_sv_clear(pTHX_ SV *_Nonnull const orig_sv) {
	sv_clear(orig_sv);
}
#endif

#ifdef sv_cmp_flags
/// Compares the strings in two SVs.  Returns -1, 0, or 1 indicating whether the
/// string in @c sv1 is less than, equal to, or greater than the string in
/// @c sv2.  Is UTF-8 and @c 'use @c bytes' aware and will coerce its args to strings
/// if necessary.  If the flags has the @c SV_GMAGIC bit set, it handles get magic.  See
/// also @c sv_cmp_locale_flags.
SWIFT_NAME(PerlInterpreter.sv_cmp_flags(self:_:_:_:))
PERL_STATIC_INLINE I32 CPerl_sv_cmp_flags(pTHX_ SV *_Nullable const sv1, SV *_Nullable const sv2, const U32 flags) {
	return sv_cmp_flags(sv1, sv2, flags);
}
#endif

#ifdef sv_cmp_locale_flags
/// Compares the strings in two SVs in a locale-aware manner.  Is UTF-8 and
/// @c 'use @c bytes' aware and will coerce its args to strings if necessary.  If
/// the flags contain @c SV_GMAGIC, it handles get magic.  See also
/// @c sv_cmp_flags.
SWIFT_NAME(PerlInterpreter.sv_cmp_locale_flags(self:_:_:_:))
PERL_STATIC_INLINE I32 CPerl_sv_cmp_locale_flags(pTHX_ SV *_Nullable const sv1, SV *_Nullable const sv2, const U32 flags) {
	return sv_cmp_locale_flags(sv1, sv2, flags);
}
#endif

#ifdef sv_copypv_flags
/// Implementation of @c sv_copypv and @c sv_copypv_nomg.  Calls get magic iff flags
/// has the @c SV_GMAGIC bit set.
SWIFT_NAME(PerlInterpreter.sv_copypv_flags(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_copypv_flags(pTHX_ SV *_Nonnull const dsv, SV *_Nonnull const ssv, const I32 flags) {
	sv_copypv_flags(dsv, ssv, flags);
}
#endif

#ifdef sv_copypv_nomg
/// Like @c sv_copypv, but doesn't invoke get magic first.
SWIFT_NAME(PerlInterpreter.sv_copypv_nomg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_copypv_nomg(pTHX_ SV *_Nonnull const dsv, SV *_Nonnull const ssv) {
	sv_copypv_nomg(dsv, ssv);
}
#endif

#ifdef sv_dec
/// Auto-decrement of the value in the SV, doing string to numeric conversion
/// if necessary.  Handles 'get' magic and operator overloading.
SWIFT_NAME(PerlInterpreter.sv_dec(self:_:))
PERL_STATIC_INLINE void CPerl_sv_dec(pTHX_ SV *_Nullable const sv) {
	sv_dec(sv);
}
#endif

#ifdef sv_dec_nomg
/// Auto-decrement of the value in the SV, doing string to numeric conversion
/// if necessary.  Handles operator overloading.  Skips handling 'get' magic.
SWIFT_NAME(PerlInterpreter.sv_dec_nomg(self:_:))
PERL_STATIC_INLINE void CPerl_sv_dec_nomg(pTHX_ SV *_Nullable const sv) {
	sv_dec_nomg(sv);
}
#endif

#ifdef sv_derived_from
/// Exactly like sv_derived_from_pv, but doesn't take a @c flags parameter.
SWIFT_NAME(PerlInterpreter.sv_derived_from(self:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_derived_from(pTHX_ SV* _Nonnull sv, const char *_Nonnull const name) {
	return sv_derived_from(sv, name);
}
#endif

#ifdef sv_derived_from_pv
/// Exactly like sv_derived_from_pvn, but takes a nul-terminated string
/// instead of a string/length pair.
SWIFT_NAME(PerlInterpreter.sv_derived_from_pv(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_derived_from_pv(pTHX_ SV* _Nonnull sv, const char *_Nonnull const name, U32 flags) {
	return sv_derived_from_pv(sv, name, flags);
}
#endif

#ifdef sv_derived_from_pvn
/// Returns a boolean indicating whether the SV is derived from the specified class
/// @i at @i the @i C @i level.  To check derivation at the Perl level, call @c isa() as a
/// normal Perl method.
///
/// Currently, the only significant value for @c flags is SVf_UTF8.
SWIFT_NAME(PerlInterpreter.sv_derived_from_pvn(self:_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_derived_from_pvn(pTHX_ SV* _Nonnull sv, const char *_Nonnull const name, const STRLEN len, U32 flags) {
	return sv_derived_from_pvn(sv, name, len, flags);
}
#endif

#ifdef sv_derived_from_sv
/// Exactly like sv_derived_from_pvn, but takes the name string in the form
/// of an SV instead of a string/length pair.
SWIFT_NAME(PerlInterpreter.sv_derived_from_sv(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_derived_from_sv(pTHX_ SV* _Nonnull sv, SV *_Nonnull namesv, U32 flags) {
	return sv_derived_from_sv(sv, namesv, flags);
}
#endif

#ifdef sv_destroyable
/// Dummy routine which reports that object can be destroyed when there is no
/// sharing module present.  It ignores its single SV argument, and returns
/// 'true'.  Exists to avoid test for a @c NULL function pointer and because it
/// could potentially warn under some level of strict-ness.
SWIFT_NAME(PerlInterpreter.sv_destroyable(self:_:))
PERL_STATIC_INLINE bool CPerl_sv_destroyable(pTHX_ SV *_Nullable sv) {
	return sv_destroyable(sv);
}
#endif

#ifdef sv_does
/// Like sv_does_pv, but doesn't take a @c flags parameter.
SWIFT_NAME(PerlInterpreter.sv_does(self:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_does(pTHX_ SV* _Nonnull sv, const char *_Nonnull const name) {
	return sv_does(sv, name);
}
#endif

#ifdef sv_does_pv
/// Like sv_does_sv, but takes a nul-terminated string instead of an SV.
SWIFT_NAME(PerlInterpreter.sv_does_pv(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_does_pv(pTHX_ SV* _Nonnull sv, const char *_Nonnull const name, U32 flags) {
	return sv_does_pv(sv, name, flags);
}
#endif

#ifdef sv_does_pvn
/// Like sv_does_sv, but takes a string/length pair instead of an SV.
SWIFT_NAME(PerlInterpreter.sv_does_pvn(self:_:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_does_pvn(pTHX_ SV* _Nonnull sv, const char *_Nonnull const name, const STRLEN len, U32 flags) {
	return sv_does_pvn(sv, name, len, flags);
}
#endif

#ifdef sv_does_sv
/// Returns a boolean indicating whether the SV performs a specific, named role.
/// The SV can be a Perl object or the name of a Perl class.
SWIFT_NAME(PerlInterpreter.sv_does_sv(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_does_sv(pTHX_ SV* _Nonnull sv, SV* _Nonnull namesv, U32 flags) {
	return sv_does_sv(sv, namesv, flags);
}
#endif

#ifdef sv_dump
/// Dumps the contents of an SV to the @c STDERR filehandle.
///
/// For an example of its output, see Devel::Peek.
SWIFT_NAME(PerlInterpreter.sv_dump(self:_:))
PERL_STATIC_INLINE void CPerl_sv_dump(pTHX_ SV* _Nonnull sv) {
	sv_dump(sv);
}
#endif

#ifdef sv_eq
/// Returns a boolean indicating whether the strings in the two SVs are
/// identical.  Is UTF-8 and @c 'use @c bytes' aware, handles get magic, and will
/// coerce its args to strings if necessary.
SWIFT_NAME(PerlInterpreter.sv_eq(self:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_eq(pTHX_ SV* _Nullable sv1, SV* _Nullable sv2) {
	return sv_eq(sv1, sv2);
}
#endif

#ifdef sv_eq_flags
/// Returns a boolean indicating whether the strings in the two SVs are
/// identical.  Is UTF-8 and @c 'use @c bytes' aware and coerces its args to strings
/// if necessary.  If the flags has the @c SV_GMAGIC bit set, it handles get-magic, too.
SWIFT_NAME(PerlInterpreter.sv_eq_flags(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_eq_flags(pTHX_ SV* _Nullable sv1, SV* _Nullable sv2, const U32 flags) {
	return sv_eq_flags(sv1, sv2, flags);
}
#endif

#ifdef sv_force_normal
/// Undo various types of fakery on an SV: if the PV is a shared string, make
/// a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
/// an @c xpvmg.  See also @c sv_force_normal_flags.
SWIFT_NAME(PerlInterpreter.sv_force_normal(self:_:))
PERL_STATIC_INLINE void CPerl_sv_force_normal(pTHX_ SV *_Nonnull sv) {
	sv_force_normal(sv);
}
#endif

#ifdef sv_force_normal_flags
/// Undo various types of fakery on an SV, where fakery means
/// "more than" a string: if the PV is a shared string, make
/// a private copy; if we're a ref, stop refing; if we're a glob, downgrade to
/// an @c xpvmg; if we're a copy-on-write scalar, this is the on-write time when
/// we do the copy, and is also used locally; if this is a
/// vstring, drop the vstring magic.  If @c SV_COW_DROP_PV is set
/// then a copy-on-write scalar drops its PV buffer (if any) and becomes
/// @c SvPOK_off rather than making a copy.  (Used where this
/// scalar is about to be set to some other value.)  In addition,
/// the @c flags parameter gets passed to @c sv_unref_flags()
/// when unreffing.  @c sv_force_normal calls this function
/// with flags set to 0.
///
/// This function is expected to be used to signal to perl that this SV is
/// about to be written to, and any extra book-keeping needs to be taken care
/// of.  Hence, it croaks on read-only values.
SWIFT_NAME(PerlInterpreter.sv_force_normal_flags(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_force_normal_flags(pTHX_ SV *_Nonnull const sv, const U32 flags) {
	sv_force_normal_flags(sv, flags);
}
#endif

#ifdef sv_free
/// Decrement an SV's reference count, and if it drops to zero, call
/// @c sv_clear to invoke destructors and free up any memory used by
/// the body; finally, deallocating the SV's head itself.
/// Normally called via a wrapper macro @c SvREFCNT_dec.
SWIFT_NAME(PerlInterpreter.sv_free(self:_:))
PERL_STATIC_INLINE void CPerl_sv_free(pTHX_ SV *_Nullable const sv) {
	sv_free(sv);
}
#endif

#ifdef sv_inc
/// Auto-increment of the value in the SV, doing string to numeric conversion
/// if necessary.  Handles 'get' magic and operator overloading.
SWIFT_NAME(PerlInterpreter.sv_inc(self:_:))
PERL_STATIC_INLINE void CPerl_sv_inc(pTHX_ SV *_Nullable const sv) {
	sv_inc(sv);
}
#endif

#ifdef sv_inc_nomg
/// Auto-increment of the value in the SV, doing string to numeric conversion
/// if necessary.  Handles operator overloading.  Skips handling 'get' magic.
SWIFT_NAME(PerlInterpreter.sv_inc_nomg(self:_:))
PERL_STATIC_INLINE void CPerl_sv_inc_nomg(pTHX_ SV *_Nullable const sv) {
	sv_inc_nomg(sv);
}
#endif

#ifdef sv_insert
/// Inserts a string at the specified offset/length within the SV.  Similar to
/// the Perl @c substr() function.  Handles get magic.
SWIFT_NAME(PerlInterpreter.sv_insert(self:_:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_insert(pTHX_ SV *_Nonnull const bigstr, const STRLEN offset, const STRLEN len, const char *_Nonnull const little, const STRLEN littlelen) {
	sv_insert(bigstr, offset, len, little, littlelen);
}
#endif

#ifdef sv_insert_flags
/// Same as @c sv_insert, but the extra @c flags are passed to the
/// @c SvPV_force_flags that applies to @c bigstr.
SWIFT_NAME(PerlInterpreter.sv_insert_flags(self:_:_:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_insert_flags(pTHX_ SV *_Nonnull const bigstr, const STRLEN offset, const STRLEN len, const char *_Nonnull little, const STRLEN littlelen, const U32 flags) {
	sv_insert_flags(bigstr, offset, len, little, littlelen, flags);
}
#endif

#ifdef sv_isa
/// Returns a boolean indicating whether the SV is blessed into the specified
/// class.  This does not check for subtypes; use @c sv_derived_from to verify
/// an inheritance relationship.
SWIFT_NAME(PerlInterpreter.sv_isa(self:_:_:))
PERL_STATIC_INLINE bool CPerl_sv_isa(pTHX_ SV* _Nullable sv, const char *_Nonnull const name) {
	return sv_isa(sv, name);
}
#endif

#ifdef sv_isobject
/// Returns a boolean indicating whether the SV is an RV pointing to a blessed
/// object.  If the SV is not an RV, or if the object is not blessed, then this
/// will return false.
SWIFT_NAME(PerlInterpreter.sv_isobject(self:_:))
PERL_STATIC_INLINE bool CPerl_sv_isobject(pTHX_ SV* _Nullable sv) {
	return sv_isobject(sv);
}
#endif

#ifdef sv_iv
/// A private implementation of the @c SvIVx macro for compilers which can't
/// cope with complex macro expressions.  Always use the macro instead.
SWIFT_NAME(PerlInterpreter.sv_iv(self:_:))
PERL_STATIC_INLINE IV CPerl_sv_iv(pTHX_ SV* _Nonnull sv) {
	return sv_iv(sv);
}
#endif

#ifdef sv_len
/// Returns the length of the string in the SV.  Handles magic and type
/// coercion and sets the UTF8 flag appropriately.  See also @c SvCUR, which
/// gives raw access to the @c xpv_cur slot.
SWIFT_NAME(PerlInterpreter.sv_len(self:_:))
PERL_STATIC_INLINE STRLEN CPerl_sv_len(pTHX_ SV *_Nullable const sv) {
	return sv_len(sv);
}
#endif

#ifdef sv_len_utf8
/// Returns the number of characters in the string in an SV, counting wide
/// UTF-8 bytes as a single character.  Handles magic and type coercion.
SWIFT_NAME(PerlInterpreter.sv_len_utf8(self:_:))
PERL_STATIC_INLINE STRLEN CPerl_sv_len_utf8(pTHX_ SV *_Nullable const sv) {
	return sv_len_utf8(sv);
}
#endif

#ifdef sv_magic
/// Adds magic to an SV.  First upgrades @c sv to type @c SVt_PVMG if
/// necessary, then adds a new magic item of type @c how to the head of the
/// magic list.
///
/// See @c sv_magicext (which @c sv_magic now calls) for a description of the
/// handling of the @c name and @c namlen arguments.
///
/// You need to use @c sv_magicext to add magic to @c SvREADONLY SVs and also
/// to add more than one instance of the same @c how.
SWIFT_NAME(PerlInterpreter.sv_magic(self:_:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_magic(pTHX_ SV *_Nonnull const sv, SV *_Nullable const obj, const int how, const char *_Nullable const name, const I32 namlen) {
	sv_magic(sv, obj, how, name, namlen);
}
#endif

#ifdef sv_magicext
/// Adds magic to an SV, upgrading it if necessary.  Applies the
/// supplied @c vtable and returns a pointer to the magic added.
///
/// Note that @c sv_magicext will allow things that @c sv_magic will not.
/// In particular, you can add magic to @c SvREADONLY SVs, and add more than
/// one instance of the same @c how.
///
/// If @c namlen is greater than zero then a @c savepvn @i copy of @c name is
/// stored, if @c namlen is zero then @c name is stored as-is and - as another
/// special case - if @c (name @c && @c namlen @c == @c HEf_SVKEY) then @c name is assumed
/// to contain an SV* and is stored as-is with its @c REFCNT incremented.
///
/// (This is now used as a subroutine by @c sv_magic.)
SWIFT_NAME(PerlInterpreter.sv_magicext(self:_:_:_:_:_:_:))
PERL_STATIC_INLINE MAGIC  *_Nonnull CPerl_sv_magicext(pTHX_ SV *_Nonnull const sv, SV *_Nullable const obj, const int how, const MGVTBL *_Nullable const vtbl, const char *_Nullable const name, const I32 namlen) {
	return sv_magicext(sv, obj, how, vtbl, name, namlen);
}
#endif

#ifdef sv_nosharing
/// Dummy routine which "shares" an SV when there is no sharing module present.
/// Or "locks" it.  Or "unlocks" it.  In other
/// words, ignores its single SV argument.
/// Exists to avoid test for a @c NULL function pointer and because it could
/// potentially warn under some level of strict-ness.
SWIFT_NAME(PerlInterpreter.sv_nosharing(self:_:))
PERL_STATIC_INLINE void CPerl_sv_nosharing(pTHX_ SV *_Nullable sv) {
	sv_nosharing(sv);
}
#endif

#ifdef sv_nounlocking
/// Dummy routine which "unlocks" an SV when there is no locking module present.
/// Exists to avoid test for a @c NULL function pointer and because it could
/// potentially warn under some level of strict-ness.
///
/// "Superseded" by @c sv_nosharing().
SWIFT_NAME(PerlInterpreter.sv_nounlocking(self:_:))
PERL_STATIC_INLINE void CPerl_sv_nounlocking(pTHX_ SV *_Nullable sv) {
	sv_nounlocking(sv);
}
#endif

#ifdef sv_nv
/// A private implementation of the @c SvNVx macro for compilers which can't
/// cope with complex macro expressions.  Always use the macro instead.
SWIFT_NAME(PerlInterpreter.sv_nv(self:_:))
PERL_STATIC_INLINE NV CPerl_sv_nv(pTHX_ SV* _Nonnull sv) {
	return sv_nv(sv);
}
#endif

#ifdef sv_pos_b2u
/// Converts the value pointed to by @c offsetp from a count of bytes from the
/// start of the string, to a count of the equivalent number of UTF-8 chars.
/// Handles magic and type coercion.
///
/// Use @c sv_pos_b2u_flags in preference, which correctly handles strings
/// longer than 2Gb.
SWIFT_NAME(PerlInterpreter.sv_pos_b2u(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_pos_b2u(pTHX_ SV *_Nullable const sv, I32 *_Nonnull const offsetp) {
	sv_pos_b2u(sv, offsetp);
}
#endif

#ifdef sv_pos_b2u_flags
/// Converts @c offset from a count of bytes from the start of the string, to
/// a count of the equivalent number of UTF-8 chars.  Handles type coercion.
/// @c flags is passed to @c SvPV_flags, and usually should be
/// @c SV_GMAGIC|SV_CONST_RETURN to handle magic.
SWIFT_NAME(PerlInterpreter.sv_pos_b2u_flags(self:_:_:_:))
PERL_STATIC_INLINE STRLEN CPerl_sv_pos_b2u_flags(pTHX_ SV *_Nonnull const sv, STRLEN const offset, U32 flags) {
	return sv_pos_b2u_flags(sv, offset, flags);
}
#endif

#ifdef sv_pos_u2b
/// Converts the value pointed to by @c offsetp from a count of UTF-8 chars from
/// the start of the string, to a count of the equivalent number of bytes; if
/// @c lenp is non-zero, it does the same to @c lenp, but this time starting from
/// the offset, rather than from the start of the string.  Handles magic and
/// type coercion.
///
/// Use @c sv_pos_u2b_flags in preference, which correctly handles strings longer
/// than 2Gb.
SWIFT_NAME(PerlInterpreter.sv_pos_u2b(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_pos_u2b(pTHX_ SV *_Nullable const sv, I32 *_Nonnull const offsetp, I32 *_Nullable const lenp) {
	sv_pos_u2b(sv, offsetp, lenp);
}
#endif

#ifdef sv_pos_u2b_flags
/// Converts the offset from a count of UTF-8 chars from
/// the start of the string, to a count of the equivalent number of bytes; if
/// @c lenp is non-zero, it does the same to @c lenp, but this time starting from
/// @c offset, rather than from the start
/// of the string.  Handles type coercion.
/// @c flags is passed to @c SvPV_flags, and usually should be
/// @c SV_GMAGIC|SV_CONST_RETURN to handle magic.
SWIFT_NAME(PerlInterpreter.sv_pos_u2b_flags(self:_:_:_:_:))
PERL_STATIC_INLINE STRLEN CPerl_sv_pos_u2b_flags(pTHX_ SV *_Nonnull const sv, STRLEN uoffset, STRLEN *_Nullable const lenp, U32 flags) {
	return sv_pos_u2b_flags(sv, uoffset, lenp, flags);
}
#endif

#ifdef sv_reftype
/// Returns a string describing what the SV is a reference to.
///
/// If ob is true and the SV is blessed, the string is the class name,
/// otherwise it is the type of the SV, "SCALAR", "ARRAY" etc.
SWIFT_NAME(PerlInterpreter.sv_reftype(self:_:_:))
PERL_STATIC_INLINE const char *_Nonnull CPerl_sv_reftype(pTHX_ const SV *_Nonnull const sv, bool ob) {
	return sv_reftype(sv, ob);
}
#endif

#ifdef sv_replace
/// Make the first argument a copy of the second, then delete the original.
/// The target SV physically takes over ownership of the body of the source SV
/// and inherits its flags; however, the target keeps any magic it owns,
/// and any magic in the source is discarded.
/// Note that this is a rather specialist SV copying operation; most of the
/// time you'll want to use @c sv_setsv or one of its many macro front-ends.
SWIFT_NAME(PerlInterpreter.sv_replace(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_replace(pTHX_ SV *_Nonnull const sv, SV *_Nonnull const nsv) {
	sv_replace(sv, nsv);
}
#endif

#ifdef sv_report_used
/// Dump the contents of all SVs not yet freed (debugging aid).
SWIFT_NAME(PerlInterpreter.sv_report_used(self:))
PERL_STATIC_INLINE void CPerl_sv_report_used(pTHX) {
	sv_report_used();
}
#endif

#ifdef sv_reset
/// Underlying implementation for the @c reset Perl function.
/// Note that the perl-level function is vaguely deprecated.
SWIFT_NAME(PerlInterpreter.sv_reset(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_reset(pTHX_ const char* _Nonnull s, HV *_Nullable const stash) {
	sv_reset(s, stash);
}
#endif

#ifdef sv_set_undef
/// Equivalent to @c sv_setsv(sv, @c &PL_sv_undef), but more efficient.
/// Doesn't handle set magic.
///
/// The perl equivalent is @c $sv @c = @c undef;. Note that it doesn't free any string
/// buffer, unlike @c undef @c $sv.
///
/// Introduced in perl 5.26.0.
SWIFT_NAME(PerlInterpreter.sv_set_undef(self:_:))
PERL_STATIC_INLINE void CPerl_sv_set_undef(pTHX_ SV *_Nonnull sv) {
	sv_set_undef(sv);
}
#endif

#ifdef sv_setiv
/// Copies an integer into the given SV, upgrading first if necessary.
/// Does not handle 'set' magic.  See also @c sv_setiv_mg.
SWIFT_NAME(PerlInterpreter.sv_setiv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setiv(pTHX_ SV *_Nonnull const sv, const IV num) {
	sv_setiv(sv, num);
}
#endif

#ifdef sv_setiv_mg
/// Like @c sv_setiv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_setiv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setiv_mg(pTHX_ SV *_Nonnull const sv, const IV i) {
	sv_setiv_mg(sv, i);
}
#endif

#ifdef sv_setnv
/// Copies a double into the given SV, upgrading first if necessary.
/// Does not handle 'set' magic.  See also @c sv_setnv_mg.
SWIFT_NAME(PerlInterpreter.sv_setnv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setnv(pTHX_ SV *_Nonnull const sv, const NV num) {
	sv_setnv(sv, num);
}
#endif

#ifdef sv_setnv_mg
/// Like @c sv_setnv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_setnv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setnv_mg(pTHX_ SV *_Nonnull const sv, const NV num) {
	sv_setnv_mg(sv, num);
}
#endif

#ifdef sv_setpv
/// Copies a string into an SV.  The string must be terminated with a @c NUL
/// character, and not contain embeded @c NUL's.
/// Does not handle 'set' magic.  See @c sv_setpv_mg.
SWIFT_NAME(PerlInterpreter.sv_setpv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setpv(pTHX_ SV *_Nonnull const sv, const char *_Nullable const ptr) {
	sv_setpv(sv, ptr);
}
#endif

#ifdef sv_setpv_mg
/// Like @c sv_setpv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_setpv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setpv_mg(pTHX_ SV *_Nonnull const sv, const char *_Nullable const ptr) {
	sv_setpv_mg(sv, ptr);
}
#endif

#ifdef sv_setpviv
/// Copies an integer into the given SV, also updating its string value.
/// Does not handle 'set' magic.  See @c sv_setpviv_mg.
SWIFT_NAME(PerlInterpreter.sv_setpviv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setpviv(pTHX_ SV *_Nonnull const sv, const IV num) {
	sv_setpviv(sv, num);
}
#endif

#ifdef sv_setpviv_mg
/// Like @c sv_setpviv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_setpviv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setpviv_mg(pTHX_ SV *_Nonnull const sv, const IV iv) {
	sv_setpviv_mg(sv, iv);
}
#endif

#ifdef sv_setpvn
/// Copies a string (possibly containing embedded @c NUL characters) into an SV.
/// The @c len parameter indicates the number of
/// bytes to be copied.  If the @c ptr argument is NULL the SV will become
/// undefined.  Does not handle 'set' magic.  See @c sv_setpvn_mg.
SWIFT_NAME(PerlInterpreter.sv_setpvn(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setpvn(pTHX_ SV *_Nonnull const sv, const char *_Nullable const ptr, const STRLEN len) {
	sv_setpvn(sv, ptr, len);
}
#endif

#ifdef sv_setpvn_mg
/// Like @c sv_setpvn, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_setpvn_mg(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setpvn_mg(pTHX_ SV *_Nonnull const sv, const char *_Nonnull const ptr, const STRLEN len) {
	sv_setpvn_mg(sv, ptr, len);
}
#endif

#ifdef sv_setref_iv
/// Copies an integer into a new SV, optionally blessing the SV.  The @c rv
/// argument will be upgraded to an RV.  That RV will be modified to point to
/// the new SV.  The @c classname argument indicates the package for the
/// blessing.  Set @c classname to @c NULL to avoid the blessing.  The new SV
/// will have a reference count of 1, and the RV will be returned.
SWIFT_NAME(PerlInterpreter.sv_setref_iv(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_sv_setref_iv(pTHX_ SV *_Nonnull const rv, const char *_Nullable const classname, const IV iv) {
	return sv_setref_iv(rv, classname, iv);
}
#endif

#ifdef sv_setref_nv
/// Copies a double into a new SV, optionally blessing the SV.  The @c rv
/// argument will be upgraded to an RV.  That RV will be modified to point to
/// the new SV.  The @c classname argument indicates the package for the
/// blessing.  Set @c classname to @c NULL to avoid the blessing.  The new SV
/// will have a reference count of 1, and the RV will be returned.
SWIFT_NAME(PerlInterpreter.sv_setref_nv(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_sv_setref_nv(pTHX_ SV *_Nonnull const rv, const char *_Nullable const classname, const NV nv) {
	return sv_setref_nv(rv, classname, nv);
}
#endif

#ifdef sv_setref_pv
/// Copies a pointer into a new SV, optionally blessing the SV.  The @c rv
/// argument will be upgraded to an RV.  That RV will be modified to point to
/// the new SV.  If the @c pv argument is @c NULL, then @c PL_sv_undef will be placed
/// into the SV.  The @c classname argument indicates the package for the
/// blessing.  Set @c classname to @c NULL to avoid the blessing.  The new SV
/// will have a reference count of 1, and the RV will be returned.
///
/// Do not use with other Perl types such as HV, AV, SV, CV, because those
/// objects will become corrupted by the pointer copy process.
///
/// Note that @c sv_setref_pvn copies the string while this copies the pointer.
SWIFT_NAME(PerlInterpreter.sv_setref_pv(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_sv_setref_pv(pTHX_ SV *_Nonnull const rv, const char *_Nullable const classname, void *_Nullable const pv) {
	return sv_setref_pv(rv, classname, pv);
}
#endif

#ifdef sv_setref_pvn
/// Copies a string into a new SV, optionally blessing the SV.  The length of the
/// string must be specified with @c n.  The @c rv argument will be upgraded to
/// an RV.  That RV will be modified to point to the new SV.  The @c classname
/// argument indicates the package for the blessing.  Set @c classname to
/// @c NULL to avoid the blessing.  The new SV will have a reference count
/// of 1, and the RV will be returned.
///
/// Note that @c sv_setref_pv copies the pointer while this copies the string.
SWIFT_NAME(PerlInterpreter.sv_setref_pvn(self:_:_:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_sv_setref_pvn(pTHX_ SV *_Nonnull const rv, const char *_Nullable const classname, const char *_Nonnull const pv, const STRLEN n) {
	return sv_setref_pvn(rv, classname, pv, n);
}
#endif

#ifdef sv_setref_uv
/// Copies an unsigned integer into a new SV, optionally blessing the SV.  The @c rv
/// argument will be upgraded to an RV.  That RV will be modified to point to
/// the new SV.  The @c classname argument indicates the package for the
/// blessing.  Set @c classname to @c NULL to avoid the blessing.  The new SV
/// will have a reference count of 1, and the RV will be returned.
SWIFT_NAME(PerlInterpreter.sv_setref_uv(self:_:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_sv_setref_uv(pTHX_ SV *_Nonnull const rv, const char *_Nullable const classname, const UV uv) {
	return sv_setref_uv(rv, classname, uv);
}
#endif

#ifdef sv_setsv
/// Copies the contents of the source SV @c ssv into the destination SV
/// @c dsv.  The source SV may be destroyed if it is mortal, so don't use this
/// function if the source SV needs to be reused.  Does not handle 'set' magic on
/// destination SV.  Calls 'get' magic on source SV.  Loosely speaking, it
/// performs a copy-by-value, obliterating any previous content of the
/// destination.
///
/// You probably want to use one of the assortment of wrappers, such as
/// @c SvSetSV, @c SvSetSV_nosteal, @c SvSetMagicSV and
/// @c SvSetMagicSV_nosteal.
SWIFT_NAME(PerlInterpreter.sv_setsv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setsv(pTHX_ SV *_Nonnull dstr, SV *_Nullable sstr) {
	sv_setsv(dstr, sstr);
}
#endif

#ifdef sv_setsv_flags
/// Copies the contents of the source SV @c ssv into the destination SV
/// @c dsv.  The source SV may be destroyed if it is mortal, so don't use this
/// function if the source SV needs to be reused.  Does not handle 'set' magic.
/// Loosely speaking, it performs a copy-by-value, obliterating any previous
/// content of the destination.
/// If the @c flags parameter has the @c SV_GMAGIC bit set, will @c mg_get on
/// @c ssv if appropriate, else not.  If the @c flags
/// parameter has the @c SV_NOSTEAL bit set then the
/// buffers of temps will not be stolen.  @c sv_setsv
/// and @c sv_setsv_nomg are implemented in terms of this function.
///
/// You probably want to use one of the assortment of wrappers, such as
/// @c SvSetSV, @c SvSetSV_nosteal, @c SvSetMagicSV and
/// @c SvSetMagicSV_nosteal.
///
/// This is the primary function for copying scalars, and most other
/// copy-ish functions and macros use this underneath.
SWIFT_NAME(PerlInterpreter.sv_setsv_flags(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setsv_flags(pTHX_ SV *_Nonnull dstr, SV *_Nullable sstr, const I32 flags) {
	sv_setsv_flags(dstr, sstr, flags);
}
#endif

#ifdef sv_setsv_mg
/// Like @c sv_setsv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_setsv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setsv_mg(pTHX_ SV *_Nonnull const dstr, SV *_Nullable const sstr) {
	sv_setsv_mg(dstr, sstr);
}
#endif

#ifdef sv_setuv
/// Copies an unsigned integer into the given SV, upgrading first if necessary.
/// Does not handle 'set' magic.  See also @c sv_setuv_mg.
SWIFT_NAME(PerlInterpreter.sv_setuv(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setuv(pTHX_ SV *_Nonnull const sv, const UV num) {
	sv_setuv(sv, num);
}
#endif

#ifdef sv_setuv_mg
/// Like @c sv_setuv, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_setuv_mg(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_setuv_mg(pTHX_ SV *_Nonnull const sv, const UV u) {
	sv_setuv_mg(sv, u);
}
#endif

#ifdef sv_taint
/// Taint an SV.  Use @c SvTAINTED_on instead.
SWIFT_NAME(PerlInterpreter.sv_taint(self:_:))
PERL_STATIC_INLINE void CPerl_sv_taint(pTHX_ SV* _Nonnull sv) {
	sv_taint(sv);
}
#endif

#ifdef sv_tainted
/// Test an SV for taintedness.  Use @c SvTAINTED instead.
SWIFT_NAME(PerlInterpreter.sv_tainted(self:_:))
PERL_STATIC_INLINE bool CPerl_sv_tainted(pTHX_ SV *_Nonnull const sv) {
	return sv_tainted(sv);
}
#endif

#ifdef sv_true
/// Returns true if the SV has a true value by Perl's rules.
/// Use the @c SvTRUE macro instead, which may call @c sv_true() or may
/// instead use an in-line version.
SWIFT_NAME(PerlInterpreter.sv_true(self:_:))
PERL_STATIC_INLINE bool CPerl_sv_true(pTHX_ SV *_Nullable const sv) {
	return sv_true(sv);
}
#endif

#ifdef sv_unmagic
/// Removes all magic of type @c type from an SV.
SWIFT_NAME(PerlInterpreter.sv_unmagic(self:_:_:))
PERL_STATIC_INLINE int CPerl_sv_unmagic(pTHX_ SV *_Nonnull const sv, const int type) {
	return sv_unmagic(sv, type);
}
#endif

#ifdef sv_unmagicext
/// Removes all magic of type @c type with the specified @c vtbl from an SV.
SWIFT_NAME(PerlInterpreter.sv_unmagicext(self:_:_:_:))
PERL_STATIC_INLINE int CPerl_sv_unmagicext(pTHX_ SV *_Nonnull const sv, const int type, MGVTBL *_Nullable vtbl) {
	return sv_unmagicext(sv, type, vtbl);
}
#endif

#ifdef sv_unref
/// Unsets the RV status of the SV, and decrements the reference count of
/// whatever was being referenced by the RV.  This can almost be thought of
/// as a reversal of @c newSVrv.  This is @c sv_unref_flags with the @c flag
/// being zero.  See @c SvROK_off.
SWIFT_NAME(PerlInterpreter.sv_unref(self:_:))
PERL_STATIC_INLINE void CPerl_sv_unref(pTHX_ SV* _Nonnull sv) {
	sv_unref(sv);
}
#endif

#ifdef sv_unref_flags
/// Unsets the RV status of the SV, and decrements the reference count of
/// whatever was being referenced by the RV.  This can almost be thought of
/// as a reversal of @c newSVrv.  The @c cflags argument can contain
/// @c SV_IMMEDIATE_UNREF to force the reference count to be decremented
/// (otherwise the decrementing is conditional on the reference count being
/// different from one or the reference being a readonly SV).
/// See @c SvROK_off.
SWIFT_NAME(PerlInterpreter.sv_unref_flags(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_unref_flags(pTHX_ SV *_Nonnull const ref, const U32 flags) {
	sv_unref_flags(ref, flags);
}
#endif

#ifdef sv_untaint
/// Untaint an SV.  Use @c SvTAINTED_off instead.
SWIFT_NAME(PerlInterpreter.sv_untaint(self:_:))
PERL_STATIC_INLINE void CPerl_sv_untaint(pTHX_ SV *_Nonnull const sv) {
	sv_untaint(sv);
}
#endif

#ifdef sv_upgrade
/// Upgrade an SV to a more complex form.  Generally adds a new body type to the
/// SV, then copies across as much information as possible from the old body.
/// It croaks if the SV is already in a more complex form than requested.  You
/// generally want to use the @c SvUPGRADE macro wrapper, which checks the type
/// before calling @c sv_upgrade, and hence does not croak.  See also
/// @c svtype.
SWIFT_NAME(PerlInterpreter.sv_upgrade(self:_:_:))
PERL_STATIC_INLINE void CPerl_sv_upgrade(pTHX_ SV *_Nonnull const sv, svtype new_type) {
	sv_upgrade(sv, new_type);
}
#endif

#ifdef sv_usepvn
/// Tells an SV to use @c ptr to find its string value.  Implemented by
/// calling @c sv_usepvn_flags with @c flags of 0, hence does not handle 'set'
/// magic.  See @c sv_usepvn_flags.
SWIFT_NAME(PerlInterpreter.sv_usepvn(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_usepvn(pTHX_ SV* _Nonnull sv, char* _Nullable ptr, STRLEN len) {
	sv_usepvn(sv, ptr, len);
}
#endif

#ifdef sv_usepvn_flags
/// Tells an SV to use @c ptr to find its string value.  Normally the
/// string is stored inside the SV, but sv_usepvn allows the SV to use an
/// outside string.  @c ptr should point to memory that was allocated
/// by Memory Management and String Handling in @c Newx|perlclib.  It must be
/// the start of a @c Newx-ed block of memory, and not a pointer to the
/// middle of it (beware of Offsets in @c OOK|perlguts and copy-on-write),
/// and not be from a non-@c Newx memory allocator like @c malloc.  The
/// string length, @c len, must be supplied.  By default this function
/// will @c Renew (i.e. realloc, move) the memory pointed to by @c ptr,
/// so that pointer should not be freed or used by the programmer after
/// giving it to @c sv_usepvn, and neither should any pointers from "behind"
/// that pointer (e.g. ptr + 1) be used.
///
/// If @c flags @c & @c SV_SMAGIC is true, will call @c SvSETMAGIC.  If
/// @c flags & SV_HAS_TRAILING_NUL> is true, then @c ptr[len] must be @c NUL,
/// and the realloc
/// will be skipped (i.e. the buffer is actually at least 1 byte longer than
/// @c len, and already meets the requirements for storing in @c SvPVX).
SWIFT_NAME(PerlInterpreter.sv_usepvn_flags(self:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_usepvn_flags(pTHX_ SV *_Nonnull const sv, char* _Nullable ptr, const STRLEN len, const U32 flags) {
	sv_usepvn_flags(sv, ptr, len, flags);
}
#endif

#ifdef sv_usepvn_mg
/// Like @c sv_usepvn, but also handles 'set' magic.
SWIFT_NAME(PerlInterpreter.sv_usepvn_mg(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_usepvn_mg(pTHX_ SV *_Nonnull sv, char *_Nullable ptr, STRLEN len) {
	sv_usepvn_mg(sv, ptr, len);
}
#endif

#ifdef sv_utf8_decode
/// If the PV of the SV is an octet sequence in Perl's extended UTF-8
/// and contains a multiple-byte character, the @c SvUTF8 flag is turned on
/// so that it looks like a character.  If the PV contains only single-byte
/// characters, the @c SvUTF8 flag stays off.
/// Scans PV for validity and returns FALSE if the PV is invalid UTF-8.
SWIFT_NAME(PerlInterpreter.sv_utf8_decode(self:_:))
PERL_STATIC_INLINE bool CPerl_sv_utf8_decode(pTHX_ SV *_Nonnull const sv) {
	return sv_utf8_decode(sv);
}
#endif

#ifdef sv_utf8_encode
/// Converts the PV of an SV to UTF-8, but then turns the @c SvUTF8
/// flag off so that it looks like octets again.
SWIFT_NAME(PerlInterpreter.sv_utf8_encode(self:_:))
PERL_STATIC_INLINE void CPerl_sv_utf8_encode(pTHX_ SV *_Nonnull const sv) {
	sv_utf8_encode(sv);
}
#endif

#ifdef sv_utf8_upgrade
/// Converts the PV of an SV to its UTF-8-encoded form.
/// Forces the SV to string form if it is not already.
/// Will @c mg_get on @c sv if appropriate.
/// Always sets the @c SvUTF8 flag to avoid future validity checks even
/// if the whole string is the same in UTF-8 as not.
/// Returns the number of bytes in the converted string
///
/// This is not a general purpose byte encoding to Unicode interface:
/// use the Encode extension for that.
SWIFT_NAME(PerlInterpreter.sv_utf8_upgrade(self:_:))
PERL_STATIC_INLINE STRLEN CPerl_sv_utf8_upgrade(pTHX_ SV *_Nonnull sv) {
	return sv_utf8_upgrade(sv);
}
#endif

#ifdef sv_utf8_upgrade_flags
/// Converts the PV of an SV to its UTF-8-encoded form.
/// Forces the SV to string form if it is not already.
/// Always sets the SvUTF8 flag to avoid future validity checks even
/// if all the bytes are invariant in UTF-8.
/// If @c flags has @c SV_GMAGIC bit set,
/// will @c mg_get on @c sv if appropriate, else not.
///
/// If @c flags has @c SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV
/// will expand when converted to UTF-8, and skips the extra work of checking for
/// that.  Typically this flag is used by a routine that has already parsed the
/// string and found such characters, and passes this information on so that the
/// work doesn't have to be repeated.
///
/// Returns the number of bytes in the converted string.
///
/// This is not a general purpose byte encoding to Unicode interface:
/// use the Encode extension for that.
SWIFT_NAME(PerlInterpreter.sv_utf8_upgrade_flags(self:_:_:))
PERL_STATIC_INLINE STRLEN CPerl_sv_utf8_upgrade_flags(pTHX_ SV *_Nonnull const sv, const I32 flags) {
	return sv_utf8_upgrade_flags(sv, flags);
}
#endif

#ifdef sv_utf8_upgrade_nomg
/// Like @c sv_utf8_upgrade, but doesn't do magic on @c sv.
SWIFT_NAME(PerlInterpreter.sv_utf8_upgrade_nomg(self:_:))
PERL_STATIC_INLINE STRLEN CPerl_sv_utf8_upgrade_nomg(pTHX_ SV *_Nonnull sv) {
	return sv_utf8_upgrade_nomg(sv);
}
#endif

#ifdef sv_uv
/// A private implementation of the @c SvUVx macro for compilers which can't
/// cope with complex macro expressions.  Always use the macro instead.
SWIFT_NAME(PerlInterpreter.sv_uv(self:_:))
PERL_STATIC_INLINE UV CPerl_sv_uv(pTHX_ SV* _Nonnull sv) {
	return sv_uv(sv);
}
#endif

#ifdef sv_vcatpvf
/// Processes its arguments like @c sv_catpvfn called with a non-null C-style
/// variable argument list, and appends the formatted output
/// to an SV.  Does not handle 'set' magic.  See @c sv_vcatpvf_mg.
///
/// Usually used via its frontend @c sv_catpvf.
SWIFT_NAME(PerlInterpreter.sv_vcatpvf(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_vcatpvf(pTHX_ SV *_Nonnull const sv, const char *_Nonnull const pat, va_list *_Nullable const args) {
	sv_vcatpvf(sv, pat, args);
}
#endif

#ifdef sv_vcatpvf_mg
/// Like @c sv_vcatpvf, but also handles 'set' magic.
///
/// Usually used via its frontend @c sv_catpvf_mg.
SWIFT_NAME(PerlInterpreter.sv_vcatpvf_mg(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_vcatpvf_mg(pTHX_ SV *_Nonnull const sv, const char *_Nonnull const pat, va_list *_Nullable const args) {
	sv_vcatpvf_mg(sv, pat, args);
}
#endif

#ifdef sv_vcatpvfn_flags
/// Processes its arguments like @c vsprintf and appends the formatted output
/// to an SV.  Uses an array of SVs if the C-style variable argument list is
/// missing (@c NULL). Argument reordering (using format specifiers like @c %2$d
/// or @c %*2$d) is supported only when using an array of SVs; using a C-style
/// @c va_list argument list with a format string that uses argument reordering
/// will yield an exception.
///
/// When running with taint checks enabled, indicates via
/// @c maybe_tainted if results are untrustworthy (often due to the use of
/// locales).
///
/// If called as @c sv_vcatpvfn or flags has the @c SV_GMAGIC bit set, calls get magic.
///
/// Usually used via one of its frontends @c sv_vcatpvf and @c sv_vcatpvf_mg.
SWIFT_NAME(PerlInterpreter.sv_vcatpvfn_flags(self:_:_:_:_:_:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_vcatpvfn_flags(pTHX_ SV *_Nonnull const sv, const char *_Nonnull const pat, const STRLEN patlen, va_list *_Nullable const args, SV *_Nullable *_Nullable const svargs, const I32 svmax, bool *_Nullable const maybe_tainted, const U32 flags) {
	sv_vcatpvfn_flags(sv, pat, patlen, args, svargs, svmax, maybe_tainted, flags);
}
#endif

#ifdef sv_vsetpvf
/// Works like @c sv_vcatpvf but copies the text into the SV instead of
/// appending it.  Does not handle 'set' magic.  See @c sv_vsetpvf_mg.
///
/// Usually used via its frontend @c sv_setpvf.
SWIFT_NAME(PerlInterpreter.sv_vsetpvf(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_vsetpvf(pTHX_ SV *_Nonnull const sv, const char *_Nonnull const pat, va_list *_Nullable const args) {
	sv_vsetpvf(sv, pat, args);
}
#endif

#ifdef sv_vsetpvf_mg
/// Like @c sv_vsetpvf, but also handles 'set' magic.
///
/// Usually used via its frontend @c sv_setpvf_mg.
SWIFT_NAME(PerlInterpreter.sv_vsetpvf_mg(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_sv_vsetpvf_mg(pTHX_ SV *_Nonnull const sv, const char *_Nonnull const pat, va_list *_Nullable const args) {
	sv_vsetpvf_mg(sv, pat, args);
}
#endif

#ifdef sync_locale
/// Changing the program's locale should be avoided by XS code.  Nevertheless,
/// certain non-Perl libraries called from XS, such as @c Gtk do so.  When this
/// happens, Perl needs to be told that the locale has changed.  Use this function
/// to do so, before returning to Perl.
SWIFT_NAME(PerlInterpreter.sync_locale(self:))
PERL_STATIC_INLINE void CPerl_sync_locale(pTHX) {
	sync_locale();
}
#endif

#ifdef unpack_str
/// The engine implementing @c unpack() Perl function.  Note: parameters @c strbeg,
/// @c new_s and @c ocnt are not used.  This call should not be used, use
/// @c unpackstring instead.
SWIFT_NAME(PerlInterpreter.unpack_str(self:_:_:_:_:_:_:_:_:))
PERL_STATIC_INLINE I32 CPerl_unpack_str(pTHX_ const char *_Nonnull pat, const char *_Nonnull patend, const char *_Nonnull s, const char *_Nullable strbeg, const char *_Nonnull strend, char *_Nullable *_Nullable new_s, I32 ocnt, U32 flags) {
	return unpack_str(pat, patend, s, strbeg, strend, new_s, ocnt, flags);
}
#endif

#ifdef unpackstring
/// The engine implementing the @c unpack() Perl function.
///
/// Using the template @c pat..patend, this function unpacks the string
/// @c s..strend into a number of mortal SVs, which it pushes onto the perl
/// argument (@c @@_) stack (so you will need to issue a @c PUTBACK before and
/// @c SPAGAIN after the call to this function).  It returns the number of
/// pushed elements.
///
/// The @c strend and @c patend pointers should point to the byte following the
/// last character of each string.
///
/// Although this function returns its values on the perl argument stack, it
/// doesn't take any parameters from that stack (and thus in particular
/// there's no need to do a @c PUSHMARK before calling it, unlike call_pv for
/// example).
SWIFT_NAME(PerlInterpreter.unpackstring(self:_:_:_:_:_:))
PERL_STATIC_INLINE I32 CPerl_unpackstring(pTHX_ const char *_Nonnull pat, const char *_Nonnull patend, const char *_Nonnull s, const char *_Nonnull strend, U32 flags) {
	return unpackstring(pat, patend, s, strend, flags);
}
#endif

#ifdef utf8_distance
/// Returns the number of UTF-8 characters between the UTF-8 pointers @c a
/// and @c b.
///
/// WARNING: use only if you *know* that the pointers point inside the
/// same UTF-8 buffer.
SWIFT_NAME(PerlInterpreter.utf8_distance(self:_:_:))
PERL_STATIC_INLINE IV CPerl_utf8_distance(pTHX_ const U8 *_Nonnull a, const U8 *_Nonnull b) {
	return utf8_distance(a, b);
}
#endif

#ifdef utf8_length
/// Return the length of the UTF-8 char encoded string @c s in characters.
/// Stops at @c e (inclusive).  If @c e @c < @c s or if the scan would end
/// up past @c e, croaks.
SWIFT_NAME(PerlInterpreter.utf8_length(self:_:_:))
PERL_STATIC_INLINE STRLEN CPerl_utf8_length(pTHX_ const U8* _Nonnull s, const U8 *_Nonnull e) {
	return utf8_length(s, e);
}
#endif

#ifdef utf8n_to_uvchr_error
/// THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
/// Most code should use utf8_to_uvchr_buf() rather than call this directly.
///
/// This function is for code that needs to know what the precise malformation(s)
/// are when an error is found.
///
/// It is like @c utf8n_to_uvchr but it takes an extra parameter placed after
/// all the others, @c errors.  If this parameter is 0, this function behaves
/// identically to @c utf8n_to_uvchr.  Otherwise, @c errors should be a pointer
/// to a @c U32 variable, which this function sets to indicate any errors found.
/// Upon return, if @c *errors is 0, there were no errors found.  Otherwise,
/// @c *errors is the bit-wise @c OR of the bits described in the list below.  Some
/// of these bits will be set if a malformation is found, even if the input
/// @c flags parameter indicates that the given malformation is allowed; those
/// exceptions are noted:
///
/// =over 4
///
/// =item @c UTF8_GOT_ABOVE_31_BIT
///
/// The code point represented by the input UTF-8 sequence occupies more than 31
/// bits.
/// This bit is set only if the input @c flags parameter contains either the
/// @c UTF8_DISALLOW_ABOVE_31_BIT or the @c UTF8_WARN_ABOVE_31_BIT flags.
///
/// =item @c UTF8_GOT_CONTINUATION
///
/// The input sequence was malformed in that the first byte was a a UTF-8
/// continuation byte.
///
/// =item @c UTF8_GOT_EMPTY
///
/// The input @c curlen parameter was 0.
///
/// =item @c UTF8_GOT_LONG
///
/// The input sequence was malformed in that there is some other sequence that
/// evaluates to the same code point, but that sequence is shorter than this one.
///
/// =item @c UTF8_GOT_NONCHAR
///
/// The code point represented by the input UTF-8 sequence is for a Unicode
/// non-character code point.
/// This bit is set only if the input @c flags parameter contains either the
/// @c UTF8_DISALLOW_NONCHAR or the @c UTF8_WARN_NONCHAR flags.
///
/// =item @c UTF8_GOT_NON_CONTINUATION
///
/// The input sequence was malformed in that a non-continuation type byte was found
/// in a position where only a continuation type one should be.
///
/// =item @c UTF8_GOT_OVERFLOW
///
/// The input sequence was malformed in that it is for a code point that is not
/// representable in the number of bits available in a UV on the current platform.
///
/// =item @c UTF8_GOT_SHORT
///
/// The input sequence was malformed in that @c curlen is smaller than required for
/// a complete sequence.  In other words, the input is for a partial character
/// sequence.
///
/// =item @c UTF8_GOT_SUPER
///
/// The input sequence was malformed in that it is for a non-Unicode code point;
/// that is, one above the legal Unicode maximum.
/// This bit is set only if the input @c flags parameter contains either the
/// @c UTF8_DISALLOW_SUPER or the @c UTF8_WARN_SUPER flags.
///
/// =item @c UTF8_GOT_SURROGATE
///
/// The input sequence was malformed in that it is for a -Unicode UTF-16 surrogate
/// code point.
/// This bit is set only if the input @c flags parameter contains either the
/// @c UTF8_DISALLOW_SURROGATE or the @c UTF8_WARN_SURROGATE flags.
///
/// =back
///
/// To do your own error handling, call this function with the @c UTF8_CHECK_ONLY
/// flag to suppress any warnings, and then examine the @c *errors return.
SWIFT_NAME(PerlInterpreter.utf8n_to_uvchr_error(self:_:_:_:_:_:))
PERL_STATIC_INLINE UV CPerl_utf8n_to_uvchr_error(pTHX_ const U8 *_Nonnull s, STRLEN curlen, STRLEN *_Nullable retlen, const U32 flags, U32 * _Nullable errors) {
	return utf8n_to_uvchr_error(s, curlen, retlen, flags, errors);
}
#endif

#ifdef vcmp
/// Version object aware cmp.  Both operands must already have been
/// converted into version objects.
SWIFT_NAME(PerlInterpreter.vcmp(self:_:_:))
PERL_STATIC_INLINE int CPerl_vcmp(pTHX_ SV *_Nonnull lhv, SV *_Nonnull rhv) {
	return vcmp(lhv, rhv);
}
#endif

#ifdef vcroak
/// This is an XS interface to Perl's @c die function.
///
/// @c pat and @c args are a sprintf-style format pattern and encapsulated
/// argument list.  These are used to generate a string message.  If the
/// message does not end with a newline, then it will be extended with
/// some indication of the current location in the code, as described for
/// mess_sv.
///
/// The error message will be used as an exception, by default
/// returning control to the nearest enclosing @c eval, but subject to
/// modification by a @c $SIG{__DIE__} handler.  In any case, the @c croak
/// function never returns normally.
///
/// For historical reasons, if @c pat is null then the contents of @c ERRSV
/// (@c $@@) will be used as an error message or object instead of building an
/// error message from arguments.  If you want to throw a non-string object,
/// or build an error message in an SV yourself, it is preferable to use
/// the croak_sv function, which does not involve clobbering @c ERRSV.
SWIFT_NAME(PerlInterpreter.vcroak(self:_:_:))
PERL_STATIC_INLINE void CPerl_vcroak(pTHX_ const char* _Nullable pat, va_list* _Nullable args) {
	vcroak(pat, args);
}
#endif

#ifdef vmess
/// @c pat and @c args are a sprintf-style format pattern and encapsulated
/// argument list, respectively.  These are used to generate a string message.  If
/// the
/// message does not end with a newline, then it will be extended with
/// some indication of the current location in the code, as described for
/// mess_sv.
///
/// Normally, the resulting message is returned in a new mortal SV.
/// During global destruction a single SV may be shared between uses of
/// this function.
SWIFT_NAME(PerlInterpreter.vmess(self:_:_:))
PERL_STATIC_INLINE SV *_Nonnull CPerl_vmess(pTHX_ const char* _Nonnull pat, va_list* _Nullable args) {
	return vmess(pat, args);
}
#endif

#ifdef vwarn
/// This is an XS interface to Perl's @c warn function.
///
/// @c pat and @c args are a sprintf-style format pattern and encapsulated
/// argument list.  These are used to generate a string message.  If the
/// message does not end with a newline, then it will be extended with
/// some indication of the current location in the code, as described for
/// mess_sv.
///
/// The error message or object will by default be written to standard error,
/// but this is subject to modification by a @c $SIG{__WARN__} handler.
///
/// Unlike with vcroak, @c pat is not permitted to be null.
SWIFT_NAME(PerlInterpreter.vwarn(self:_:_:))
PERL_STATIC_INLINE void CPerl_vwarn(pTHX_ const char* _Nonnull pat, va_list* _Nullable args) {
	vwarn(pat, args);
}
#endif

#ifdef warn_sv
/// This is an XS interface to Perl's @c warn function.
///
/// @c baseex is the error message or object.  If it is a reference, it
/// will be used as-is.  Otherwise it is used as a string, and if it does
/// not end with a newline then it will be extended with some indication of
/// the current location in the code, as described for mess_sv.
///
/// The error message or object will by default be written to standard error,
/// but this is subject to modification by a @c $SIG{__WARN__} handler.
///
/// To warn with a simple string message, the warn function may be
/// more convenient.
SWIFT_NAME(PerlInterpreter.warn_sv(self:_:))
PERL_STATIC_INLINE void CPerl_warn_sv(pTHX_ SV *_Nonnull baseex) {
	warn_sv(baseex);
}
#endif

#ifdef wrap_op_checker
/// Puts a C function into the chain of check functions for a specified op
/// type.  This is the preferred way to manipulate the PL_check array.
/// @c opcode specifies which type of op is to be affected.  @c new_checker
/// is a pointer to the C function that is to be added to that opcode's
/// check chain, and @c old_checker_p points to the storage location where a
/// pointer to the next function in the chain will be stored.  The value of
/// @c new_pointer is written into the PL_check array, while the value
/// previously stored there is written to @c *old_checker_p.
///
/// The function should be defined like this:
///
/// @code
/// static OP *new_checker(pTHX_ OP *op) { ... }
/// @endcode
///
/// It is intended to be called in this manner:
///
/// @code
/// new_checker(aTHX_ op)
/// @endcode
///
/// @c old_checker_p should be defined like this:
///
/// @code
/// static Perl_check_t old_checker_p;
/// @endcode
///
/// PL_check is global to an entire process, and a module wishing to
/// hook op checking may find itself invoked more than once per process,
/// typically in different threads.  To handle that situation, this function
/// is idempotent.  The location @c *old_checker_p must initially (once
/// per process) contain a null pointer.  A C variable of static duration
/// (declared at file scope, typically also marked @c static to give
/// it internal linkage) will be implicitly initialised appropriately,
/// if it does not have an explicit initialiser.  This function will only
/// actually modify the check chain if it finds @c *old_checker_p to be null.
/// This function is also thread safe on the small scale.  It uses appropriate
/// locking to avoid race conditions in accessing PL_check.
///
/// When this function is called, the function referenced by @c new_checker
/// must be ready to be called, except for @c *old_checker_p being unfilled.
/// In a threading situation, @c new_checker may be called immediately,
/// even before this function has returned.  @c *old_checker_p will always
/// be appropriately set before @c new_checker is called.  If @c new_checker
/// decides not to do anything special with an op that it is given (which
/// is the usual case for most uses of op check hooking), it must chain the
/// check function referenced by @c *old_checker_p.
///
/// If you want to influence compilation of calls to a specific subroutine,
/// then use cv_set_call_checker rather than hooking checking of all
/// @c entersub ops.
SWIFT_NAME(PerlInterpreter.wrap_op_checker(self:_:_:_:))
PERL_STATIC_INLINE void CPerl_wrap_op_checker(pTHX_ Optype opcode, Perl_check_t _Nonnull new_checker, Perl_check_t _Nonnull *_Nonnull old_checker_p) {
	wrap_op_checker(opcode, new_checker, old_checker_p);
}
#endif

#if !(defined(HAS_MEMMEM))
#endif
#if !(defined(HAS_SIGACTION) && defined(SA_SIGINFO))
#endif
#if !(defined(PERL_GLOBAL_STRUCT_PRIVATE))
#  if defined(PERL_IMPLICIT_CONTEXT)
#  endif
#endif
#if !(defined(WIN32))
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
#endif
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
#endif
#if !defined(HAS_MEMCPY) || (!defined(HAS_MEMMOVE) && !defined(HAS_SAFE_MEMCPY))
#endif
#if !defined(HAS_MEMSET)
#endif
#if !defined(HAS_SIGNBIT)
#endif
#if !defined(HAS_STRLCAT)
#endif
#if !defined(HAS_STRLCPY)
#endif
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
#endif
#if !defined(PERL_IMPLICIT_SYS)
#endif
#if !defined(PERL_NO_INLINE_FUNCTIONS)
#endif
#if !defined(SPRINTF_RETURNS_STRLEN)
#endif
#if defined(DEBUGGING)
#ifdef pad_setsv
/// Set the value at offset @c po in the current (compiling or executing) pad.
/// Use the macro @c PAD_SETSV() rather than calling this function directly.
SWIFT_NAME(PerlInterpreter.pad_setsv(self:_:_:))
PERL_STATIC_INLINE void CPerl_pad_setsv(pTHX_ PADOFFSET po, SV* _Nonnull sv) {
	pad_setsv(po, sv);
}
#endif

#  if defined(USE_LOCALE)     && (defined(PERL_IN_LOCALE_C) || defined (PERL_EXT_POSIX))
#  endif
#endif
#if defined(HAS_MEMMEM)
#endif
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#endif
#if defined(HAVE_INTERP_INTERN)
#  if defined(USE_ITHREADS)
#  endif
#endif
#if defined(MYMALLOC)
#endif
#if defined(PERL_DONT_CREATE_GVSV)
#endif
#if defined(PERL_GLOBAL_STRUCT)
#endif
#if defined(PERL_GLOBAL_STRUCT_PRIVATE)
#  if defined(PERL_IMPLICIT_CONTEXT)
#  endif
#endif
#if defined(PERL_IMPLICIT_CONTEXT)
#endif
#if defined(PERL_IMPLICIT_SYS)
#  if defined(USE_ITHREADS)
#  endif
#endif
#if defined(PERL_OP_PARENT)
#endif
#if defined(UNLINK_ALL_VERSIONS)
#endif
#if defined(USE_C_BACKTRACE)
#ifdef dump_c_backtrace
/// Dumps the C backtrace to the given @c fp.
///
/// Returns true if a backtrace could be retrieved, false if not.
SWIFT_NAME(PerlInterpreter.dump_c_backtrace(self:_:_:_:))
PERL_STATIC_INLINE bool CPerl_dump_c_backtrace(pTHX_ PerlIO* _Nonnull fp, int max_depth, int skip) {
	return dump_c_backtrace(fp, max_depth, skip);
}
#endif

#endif
#if defined(USE_ITHREADS)
#endif
#if defined(USE_LOCALE)     && (defined(PERL_IN_LOCALE_C) || defined (PERL_EXT_POSIX))
#endif
#if defined(USE_LOCALE_COLLATE)
#endif
#if defined(USE_PERLIO)
#endif
#if defined(USE_QUADMATH)
#ifdef quadmath_format_needed
/// @c quadmath_format_needed() returns true if the @c format string seems to
/// contain at least one non-Q-prefixed @c %[efgaEFGA] format specifier,
/// or returns false otherwise.
///
/// The format specifier detection is not complete printf-syntax detection,
/// but it should catch most common cases.
///
/// If true is returned, those arguments @b should in theory be processed
/// with @c quadmath_snprintf(), but in case there is more than one such
/// format specifier (see quadmath_format_single), and if there is
/// anything else beyond that one (even just a single byte), they
/// @b cannot be processed because @c quadmath_snprintf() is very strict,
/// accepting only one format spec, and nothing else.
/// In this case, the code should probably fail.
SWIFT_NAME(quadmath_format_needed(_:))
PERL_STATIC_INLINE bool CPerl_quadmath_format_needed(const char* _Nonnull format) {
	return quadmath_format_needed(format);
}
#endif

#endif
#if defined(WIN32)
#endif
#if defined(WIN32) || defined(__SYMBIAN32__) || defined(VMS)
#endif
